<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTTP与HTTPS，一些关键地方的理解</title>
      <link href="2021/04/07/20210407/"/>
      <url>2021/04/07/20210407/</url>
      
        <content type="html"><![CDATA[<p>最近在面试中被问到了HTTP与HTTPS的一些问题，今天稍微学习了一下HTTP与HTTPS，在这里整理一下一些重要地方的理解。</p><a id="more"></a><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><strong>HTTP基础：</strong><br><a href="https://juejin.cn/post/6844903592965439501#heading-13">面试带你飞：这是一份全面的 计算机网络基础 总结攻略</a><br><a href="https://www.jianshu.com/p/a6d086a3997d">计算机网络：这是一份全面&amp; 详细 HTTP知识讲解</a><br><strong>HTTP与HTTPS:</strong><br><a href="https://juejin.cn/post/6844903608421449742">看图学HTTPS</a><br><a href="https://zhuanlan.zhihu.com/p/96494976">你知道，HTTPS用的是对称加密还是非对称加密？</a><br><a href="http://www.52im.net/thread-2027-1-1.html">一分钟理解 HTTPS 到底解决了什么问题</a><br>主要对于证书与数字签名一些理解来自于这篇博客：<br><a href="http://www.52im.net/thread-1890-1-1.html">即时通讯安全篇（七）：如果这样来理解HTTPS，一篇就够了</a></p><h2 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h2><p><img src="https://upload-images.jianshu.io/upload_images/944365-820f955afd57185f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/712/format/webp" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/944365-820f955afd57185f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/712/format/webp" srcset="data:image/png;base64,666" alt="区别"></p><h2 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h2><p>加密和解密用同一个秘钥的加密方式叫做<strong>对称加密</strong>。对于对称加密来说，服务器与客户端使用相同的加密方式，但是对于多个客户的系统来说，如果都采用同样的加密方式，那么一旦攻击者对于加密方式进行了破解，那么所有用户都将处于风险下。如果对不同用户使用不同方式进行加密，那么如果攻击者也对于加密方法进行拦截并破解，那么依然可能使用户暴露于安全风险下。</p><p>这时我们可以采用非对称加密的方法。 非对称加密会有一对秘钥：<strong>公钥和私钥</strong>。 <strong>公钥加密的内容，只有私钥可以解开，私钥加密的内容，所有的公钥都可以解开（当然是指和秘钥是一对的公钥）。</strong> 私钥只在服务器端且不公开，而公钥面向用户公开。<strong>这样，至少可以保证用户通过公钥加密的内容无法被攻击者破解（必须要拥有私钥才能解密）。</strong></p><p>当然，这样依然会存在问题，公钥可能被中间人拿到篡改，偷偷换成他自己的公钥，这样客户使用假的公钥加密的内容将被中间人的私钥破解，然后肆意篡改。<br><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d56d46dc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2018/5/21/1638197d56d46dc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="data:image/png;base64,666" alt="示意图"></p><p>公钥被掉包，是因为客户端无法分辨传回公钥的到底是中间人，还是服务器，这也是密码学中的身份验证问题。这样，我们就可以引入<strong>证书+数字签名</strong>的方法来解决这样的问题。</p><h2 id="证书与数字签名"><a href="#证书与数字签名" class="headerlink" title="证书与数字签名"></a>证书与数字签名</h2><p>服务器可以通过第三方认证机构，可以让第三方机构对自己的公钥进行加密，然后将加密后的公钥发放给客户。那么，客户如何确定自己收到的第三方加密证书是真正的服务器发来的证书，而不是中间人自己通过向第三方机构申请获得的伪造证书呢？原来，在数字证书上还附有数字签名这一东西，用参考博客里的一句原话举例：</p><p>我们从现实中找灵感。比如你是HR，你手上拿到候选人的学历证书，证书上写了持证人，颁发机构，颁发时间等等，同时证书上，还写有一个最重要的：证书编号！我们怎么鉴别这张证书是的真伪呢？只要拿着这个证书编号上相关机构去查，如果证书上的持证人与现实的这个候选人一致，同时证书编号也能对应上，那么就说明这个证书是真实的。</p><p>现实中，浏览器和操作系统都会维护一个权威的第三方机构列表（包括它们的公钥）。因为客户端接收到的证书中会写有颁发机构，客户端就根据这个颁发机构的值在本地找相应的公钥。并用公钥对证书上的内容进行解密，比对数字签名。由于数字签名这一东西是由服务端向第三方机构申请，并<strong>通过第三方机构私钥产生的</strong>，因此中间人不能伪造数字签名，以假装自己是真正的服务端，<strong>如果中间人使用了自己申请的伪造证书，那么在客户端对于证书内容解密后，会出现验证签名不匹配的情况，这样客户端就会提醒用户可能存在的安全风险了。</strong></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>由于使用了数字证书，加密解密这样的方法，导致HTTPS相比于普通的HTTP要慢得多，但是只有支持了 HTTPS，才能部署 HTTP/2，而 HTTP/2 协议会提升速度，能够有效减轻客户端和服务器端的压力，让响应更快速。这一点就要联系到HTTP不同版本之前的区别，以及HTTP的历史了。</p><p><img src="https://pic4.zhimg.com/80/v2-1ea0209a526f3527a713736fe7609fcf_720w.jpg" class="lazyload" data-srcset="https://pic4.zhimg.com/80/v2-1ea0209a526f3527a713736fe7609fcf_720w.jpg" srcset="data:image/png;base64,666" alt="HTTPS的整体实现过程"><br>这张图片中显示的HTTPS在进行证书验证之后，客户端与服务端直接使用了对称加密的方法进行了数据传输，但是依然使用了公钥和私钥进行了加密解密，这一点我没有太搞懂，另外SSL和TLS这些名词的含义也还没有整明白，明天再看看吧。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>画饼</title>
      <link href="2021/03/06/20210306/"/>
      <url>2021/03/06/20210306/</url>
      
        <content type="html"><![CDATA[<p>最近学习生活繁忙，先画一些大饼，能不能完成以后再说。。。ヽ(。&gt;д&lt;)ｐ</p><a id="more"></a><h2 id="LeetCode生成题解md脚本"><a href="#LeetCode生成题解md脚本" class="headerlink" title="LeetCode生成题解md脚本"></a>LeetCode生成题解md脚本</h2><p>经历了大概两个月的摸鱼，最近终于又重新开始搞LeetCode了，其实之前一直想整一个可以自动生成题解的框架，就像我之前的一些文章一样自动生成题目链接，题目简介，示例输入输出，甚至代码这样的脚本。其实实现起来应该并不难，只需要做一个爬虫就好了，然后解析一下网页把相关的内容粘下来，不过由于懒一直都没有做。。。</p><h2 id="网易BUFF-amp-amp-Steam社区市场爬虫"><a href="#网易BUFF-amp-amp-Steam社区市场爬虫" class="headerlink" title="网易BUFF &amp;&amp; Steam社区市场爬虫"></a>网易BUFF &amp;&amp; Steam社区市场爬虫</h2><p>这个也是老早就想做的了，由于自己是一名csgo玩家，很早之前就想做一个爬虫软件，自动将buff和steam市场的数据爬下来自己使用，当然网上也有很多现成的代码，不知道能不能使用，不过这个也是从去年就开始计划做的东西了。。。</p><h2 id="GitHub密钥设置"><a href="#GitHub密钥设置" class="headerlink" title="GitHub密钥设置"></a>GitHub密钥设置</h2><p>把这篇文章传上去之后，我收到了GitHub发来的一篇邮件，里面说要使用新的git认证方式：</p><div class="note quote"><p><strong>GitHub</strong></p><p>Hi @YazidZidane,</p><p>You recently used a password to access the repository at YazidZidane/yazidzidane.github.io with git using git/2.29.2.windows.3.</p><p>Basic authentication using a password to Git is deprecated and will soon no longer work. Visit <a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/">https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/</a> for more information around suggested workarounds and removal dates.</p><p>Thanks,<br>The GitHub Team</p></div><p>这个我暂时还没整明白是咋回事，不知道是不是跟之前搞过的ssh key一样，总之应该尽快搞一下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode435 无重叠区间</title>
      <link href="2020/12/31/20201231-leetcode/"/>
      <url>2020/12/31/20201231-leetcode/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a><br><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a><br>使用贪心算法解决区间问题。</p><a id="more"></a><div class="note link green"><p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">https://leetcode-cn.com/problems/non-overlapping-intervals/</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></div><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>注意:</strong></p><ul><li>可以认为区间的终点总是大于它的起点。</li><li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li></ul><p><strong>示例 1:</strong></p><div class="note "><p><strong>输入</strong>: [[1,2],[2,3],[3,4],[1,3]] <br> <strong>输出</strong>: 1 <br> <strong>解释</strong>: 移除 [1,3] 后，剩下的区间没有重叠。</p></div><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>这道题看上去感觉还行，我第一时间想到的就是把区间看成一个一个的槽，让每个槽里只有一个元素，但这样过于抽象，不好实现。后来又想了想，觉得应该用排序，先将所有的区间按照区间开始位置进行排序，然后使用贪心算法，删除每一对相互重叠的两个区间中较大的一个。后来想了想，应该删除<strong>区间结束位置最大的一个</strong>。</p><p>这道题对我来说难点在于判断<strong>如何使用贪心算法</strong>，这里不太好想一个证明方法，我直接复制了LeetCode上的证明：</p><div class="note link green"><p>我们不妨想一想应该选择哪一个区间作为首个区间。 <br> 假设在某一种<strong>最优</strong>的选择方法中，[lk,rk] 是首个（即最左侧的）区间，那么它的左侧没有其它区间，右侧有若干个不重叠的区间。设想一下，如果此时存在一个区间 [lj,rj]，使得 rj &lt; rk ，即区间 j 的右端点在区间 k 的左侧，那么我们将区间 k 替换为区间 j，其与剩余右侧被选择的区间仍然是不重叠的。而当我们将区间 k 替换为区间 j 后，就得到了<strong>另一种最优</strong>的选择方法。</p></div><p>有了证明后，程序实现的方法就很好想了，可以使用双指针的方法，一个指针指向当前节点，另一个指针指向下一个节点，然后判断两个节点所在的区间是否重叠。这里可以直接比较第一个区间的结尾与第二个区间的开始的大小，如果两个区间重叠，那么应该有<strong>后面的区间的开始位置&lt;前面区间的结束位置</strong>。然后删除结束位置最大的节点，其实在实现时也并不需要真的删除节点，只要移动<code>next</code>指针就可以了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mincount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//首先对区间数组按照区间开始的位置进行排序</span></span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>, next = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (next &lt; intervals.size()) &#123;</span><br><span class="line">            <span class="comment">//如果后面的区间的开始位置&lt;前面区间的结束位置， 说明两区间有重叠</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[curr][<span class="number">1</span>] &gt; intervals[next][<span class="number">0</span>]) &#123;</span><br><span class="line">                mincount++;</span><br><span class="line">                <span class="comment">//比较两区间结束位置，删除结束位置最大的</span></span><br><span class="line">                intervals[curr][<span class="number">1</span>] &gt; intervals[next][<span class="number">1</span>] ? curr = next : curr = curr ;</span><br><span class="line">                next++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//两区间不重叠，双指针向前移动</span></span><br><span class="line">                curr = next;</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mincount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外我在代码中遇到的错误就是忘记将<code>curr</code>设置为<code>next</code>的值，而是直接<code>curr++</code>，这样将导致<code>curr</code>移动到已经删除的节点上。</p><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>这道题的题干太长了而且描述的非常弱智，懒得在这抄了，直接放链接：</p><div class="note link green"><p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></div><p><strong>示例 1：</strong></p><div class="note "><p><strong>输入</strong>：points = [[10,16],[2,8],[1,6],[7,12]] <br> <strong>输出</strong>：2 <br> <strong>解释</strong>：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</p></div><p><strong>示例 2：</strong></p><div class="note "><p><strong>输入：</strong>points = [[1,2],[3,4],[5,6],[7,8]] <br> <strong>输出：</strong>4</p></div><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>这道题跟上面一道题类似，都是要找到区间数组中的重叠区间，但这题对于重叠区间进行了限制，即要求所有的重叠区间全部包含一个值/区间，如果我们把这些区间纵向排列，可以想象成用一根箭贯穿他们或是用一根棍把它们串起来。一开始我也想使用与上一题类似的排序+双指针方法直接求解，可这回我发现答案却错误了，具体错误如下：</p><div class="note "><p>输入：[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] <br> 输出：1 <br> 预期：2</p></div><p>可以发现，代码虽然可以通过题目示例里的几个测试用例，但是却不能通过这个用例，这是因为，除去输入数组的第一项<code>[9,12]</code>以外，其他的数组都可以覆盖一个区间<code>[6,7]</code>，而区间<code>[9,12]</code>显然不包含这一区间。我们在上一题中通过判断前一区间的右端点和下一区间的左端点的大小，来判断两个区间是否相互覆盖。但这题中我们就需要动态地修改右端点的大小，保证所有相互覆盖的区间都能覆盖到一个相同的区间，即“用一颗子弹贯穿这些区间”。</p><p>于是在第一份代码中，我们使用了<code>r</code>来表示当前区间的最右端点，并在每一次遍历到新的区间时动态修改<code>r</code>，保证所有的当前区间均能被一颗子弹贯穿。值得注意的是，每次遍历完一个这样的区间集合时，也就是在<code>else</code>中才将<code>arrows</code>加一，这样在最后一次遍历后<code>arrows</code>会少<code>1</code>，所以在最后返回<code>arrows+1</code>。</p><p>而在参考答案写出的第二份代码中，由于本题中判断区间是否可被子弹打穿，主要依据的是每一个区间的右端点值，因此可以使用一种贪心的思想，每次将子弹射入的位置设定为拥有最小右端点的区间的右端点值。于是我们可以将区间按照右端点大小进行排序，这里使用了C++中的<strong>lambda表达式</strong>方法，这个方法我还不是太熟悉，<strong>具体如何使用之后应该再了解一下</strong>。总之，将所有区间排序后，我们将最小的右端点设定为子弹射入的位置，并依旧向下遍历判断下一个区间的左端点，与当前射入位置的大小，这样就可以判断子弹是否能一次贯穿这两个区间了。</p><p>这个方法相比于最开始的代码，主要是在判断上节省了判断次数，因此消耗的时间也要明显少一些。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!points.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arrows = <span class="number">0</span>;</span><br><span class="line">        sort(points.begin(), points.end());</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>, next = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (next &lt; points.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[next][<span class="number">0</span>] &lt;= r) &#123;</span><br><span class="line">                r = r &gt;= points[next][<span class="number">1</span>] ? points[next][<span class="number">1</span>] : r;    </span><br><span class="line">                next++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = next;</span><br><span class="line">                r = points[curr][<span class="number">1</span>];</span><br><span class="line">                next++;</span><br><span class="line">                arrows++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrows + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!points.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arrows = <span class="number">1</span>;</span><br><span class="line">        sort(points.begin(), points.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; u, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> pos = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &lt;= pos) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pos = points[i][<span class="number">1</span>];</span><br><span class="line">                arrows++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrows;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode1046 最后一块石头的重量</title>
      <link href="2020/12/30/20201230-leetcode/"/>
      <url>2020/12/30/20201230-leetcode/</url>
      
        <content type="html"><![CDATA[<p>使用priority_queue解决最大堆问题。</p><a id="more"></a><div class="note link green"><p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/last-stone-weight">https://leetcode-cn.com/problems/last-stone-weight</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></div><h2 id="1046-最后一块石头的重量"><a href="#1046-最后一块石头的重量" class="headerlink" title="1046. 最后一块石头的重量"></a>1046. 最后一块石头的重量</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">    先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，</span><br><span class="line">    再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，</span><br><span class="line">    接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，</span><br><span class="line">    最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>这道题读完题后感觉并不是太难，只要对这堆石头，每次找出最大的两块然后敲碎，全部丢掉或者留下一块小石头继续就行了。可是我却很难想到一个高效的方法来解决这个问题。如果要使用一个有效的数据结构，那么这个结构要能保存一个按大小排列的数组，并在每次取出最大的两个数后，将可能剩下的一个数插入数组，并保持数组的有序性。如果每次都使用一次排序的话未免太复杂了些，如果使用之前刚刚学过的单调栈，又不能在敲碎两块石头后有效的处理剩下的一块石头。队列和栈看起来也不好处理这个问题。无奈之下只好再次求助答案，结果看到了“最大堆”这个说法，恍然大悟！</p><p>其实堆很久以前数据结构就学过，大致记得是一个以二叉树形式存储数据，使所有数据满足“父节点的数值大于子节点数值”的一个数据结构。在学排序的时候还学过堆排序，应该就是先构建一个堆，然后就很好排序了。不过说实话我早就忘记了怎么实现这个数据结构，<strong>看来之后还要好好复习一下</strong>。。。。。。不过我也不记得STL里面专门有heap这种类型的数据结构，所以虽然知道了大概的方法，但还是写不出来😂</p><p>又瞟了一眼别人答案的代码，一眼看到了一个奇怪的东西<code>priority_queue</code>，我寻思队列怎么跟堆也扯不上关系，为啥这个优先队列就行呢？结果一看优先队列的使用方式才发现，这个“优先”正是通过堆来实现的！</p><p>优先队列<code>priority_queue</code>通过与普通<code>queue</code>不同的地方就在于，队列中的数据优先级可以定义，并自动根据优先级排队，按照优先级顺序出队。其余入队、出队的方式就与<code>queue</code>一样了。底层由一个堆实现，默认是按照<strong>大根堆</strong>来实现的，也就是说，大的元素在最顶端。于是在这道题中，就可以将所有石块加入这个优先队列，这样他们就会自动按照从大到小的顺序排序，并在每次更新，加入新的石块时仍然保持排序不变。</p><p>按照概念自己瞎写了个代码，最终正确通过了，看来以后还是在刷题的同时要好好学习和复习数据结构方面的知识。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt;heap;</span><br><span class="line">        <span class="comment">// int stone = stones.size();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.size(); i++) &#123;</span><br><span class="line">            heap.push(stones[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (heap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            <span class="keyword">int</span> y = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                heap.push(x - y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!heap.empty()) <span class="keyword">return</span> heap.top();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 最大堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode739 每日温度</title>
      <link href="2020/12/25/20201225-leetcode/"/>
      <url>2020/12/25/20201225-leetcode/</url>
      
        <content type="html"><![CDATA[<p>第一次学习使用神奇的单调栈方法解每日温度问题。</p><a id="more"></a><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请根据每日 <code>气温</code> 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p><strong>提示</strong>：气温 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在 <code>[30, 100]</code> 范围内的整数。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>这道题开始看到题后我毫无头绪，除了用暴力解以外也完全想不出什么好办法，之前看过了好多遍，连看答案都看不太明白，也没能真正下手开始做。今天在学习leetbook中的“栈”部分时候再次遇到了这道题，决定认真学习一下。</p><p>题目官方解析的暴力法完全看不懂，各种数组套来套去不知道在说什么，故直接跳转到第二个方法————<strong>单调栈</strong>。单调栈法的文字部分也看不太懂，可是有例子就非常容易搞明白了。看了看例子，大概的思想是<strong>维护一个单调递减的栈</strong>，由于我们要找到每一个温度后面的第一个更高的温度，所以当后面温度是递减或相等的时候就把它们压入栈中保存。</p><p>如果我们遇到了比栈顶元素更高的值，那么可以有两种情况：</p><ul><li>该值比栈中的所有元素都要大，将所有元素依次出栈后将该值压栈。</li><li>该值比栈中部分元素大，将该部分元素依次出栈后将该值压栈。</li></ul><p>由于我们在栈中保存了之前单调递减的所有元素，所以我们可以以这些元素为依据来求出题目中要求的<strong>第一个更高的气温</strong>。我们可以用官方答案的例子作为参考。具体实现可以参考如下代码。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;                    <span class="comment">//s保存所有的温度值</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;index;                <span class="comment">//index保存所有的索引值，与s栈保持一致</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result(T.size(), <span class="number">-1</span>);<span class="comment">//全部初始化为-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty())&#123;</span><br><span class="line">                s.push(T[i]);</span><br><span class="line">                index.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(T[i] &gt; s.top())&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(T[i] &gt; s.top())&#123;</span><br><span class="line">                        s.pop();</span><br><span class="line">                        result[index.top()] = i - index.top();</span><br><span class="line">                        index.pop();</span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        s.push(T[i]);</span><br><span class="line">                        index.push(i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;                  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s.empty())&#123;</span><br><span class="line">                    s.push(T[i]);</span><br><span class="line">                    index.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.push(T[i]);</span><br><span class="line">                index.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                result[index.top()] = <span class="number">0</span>;</span><br><span class="line">                index.pop();                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最开始写的代码，按照我初始的逻辑写好的，又臭又长，中间有好多重复的部分可以优化。首先定义两个栈<code>s</code>和<code>index</code>，分别保存温度值和温度值对应的数组索引值，并初始化一个大小为<code>n</code>的数组<code>result</code>保存所有的结果。</p><p>代码运行时，首先对于每一个温度值进行判断，如果栈为空或该值小于栈顶值就将其加入栈中，如果大于栈顶元素时，根据上文说过的逻辑进行操作。将栈顶元素出栈，并在<code>result</code>数组中计算两个温度值对应索引的差值。然后再继续进行判断该值与下一个栈顶元素值的大小。</p><p>可以看到该代码中有太多重复的部分，完全可以将压栈的部分放到一起，于是进行修改之后可以得到如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;index;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result(T.size(), <span class="number">0</span>);<span class="comment">//全部初始化为0,最后不用再加上处理步骤</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.size(); i++)&#123;            </span><br><span class="line">            <span class="keyword">while</span>(!index.empty() &amp;&amp; T[i] &gt; T[index.top()])&#123;</span><br><span class="line">                result[index.top()] = i - index.top();</span><br><span class="line">                index.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            index.push(i);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考答案后优化的代码，其实跟我自己按照上面代码优化的差不太多，唯一难想到的大概就是只使用<code>index</code>一个栈来表示温度数组，由于<code>index</code>保存了所有的索引，因此可以很自然的通过<code>T[i]</code>来索引到每一个温度的值。</p><p>除此之外，这是LeetCode上的一篇题解，上面介绍了递增栈递减栈的用法和怎么用，我感觉看完之后收获很大。</p><p><a href="https://leetcode-cn.com/problems/daily-temperatures/solution/shou-hui-ti-jie-fang-da-guan-cha-dan-diao-zhan-si-/">很有用的题解参考</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论中国足球限薪令及球队名称中性化政策</title>
      <link href="2020/12/24/20201224-football/"/>
      <url>2020/12/24/20201224-football/</url>
      
        <content type="html"><![CDATA[<p>第一次写关于中国足球的内容，文笔不好，如果文不达意还请谅解。</p><a id="more"></a><p>最近，随着中超以及足协杯，亚冠等赛事结束，2020赛季算是正式落下了帷幕，这个赛季我们一同见证了亚泰时隔两年，终于以碾压之势以中甲冠军身份成功冲超，可喜可贺，也见证了苏宁终于圆梦中超，鲁能登顶足协杯。赛季结束后，中国足协接连召开会议，发表了许多对于球队限薪，投入限制等方面的政策，这其中最令人关注的就是球队限薪令以及中姓名政策了，而这两条新政也势必会对中超乃至国足很大影响。</p><h2 id="球员限薪"><a href="#球员限薪" class="headerlink" title="球员限薪"></a>球员限薪</h2><p>对于球队限薪令来说，将外援以及国内球员的年薪全部进行限制。不难理解，足协推出这项政策的本意是希望改变现在中国足球畸形的工资情况，部分外援的工资可以在世界范围内排的上号，而国内顶尖球员的工资也是令人咋舌。对于这样的工资，许多不关注中国足球的人经常以其作为依据来批判国足，称其“领着极高薪水，表现却相差了十万八千里”，虽然我本身并不是国足的球迷，甚至有些讨厌国足，但在之前看到这样的评论，也总是忍不住要杠一下。毕竟国足再不济，也是这个国家踢足球表现最好的二三十个人了。你在任何一个行业，做到一个国家的顶尖水平，拿到最高的薪水，难道有什么问题吗？</p><p>不过，这次的限薪政策一出，还是说明了我之前所没有考虑到的一个问题，那就是工资结构。其实之前在玩fm的时候我也注意到了，我在游戏中曾经执教过亚泰和还没解散的辽宁宏运，两家球队都是资金并不富裕，而相比于恒大，上港这样的球队，相差最大的不只是球队资金，还有球员工资。对于亚泰来说，球队工资最高的小妖和塞鸟，大概是70万每周，而主力国内球员的薪资，可能就只有四五万了，更不用说年轻球员的工资。跟恒大相比，光是国内球员的薪资水平就相差了几倍甚至十倍以上，外援就更不用说了。同时在游戏里，外援反而是最容易签下的，因为一名还不错的国内球员，甚至比外援还要稀有，而普通球员之间的差距并不是很大，于是签下一名“能用的”国内球员，需要花费的代价有时比买一名中超级别的外援还要大。我虽然不知道现实中球队的工资水平和球队资金，但从各种方面来看，可能也跟游戏里差不多了。这样下去，只会导致好的球员越来越贵，工资越来越高，穷的球队越来越养不起球员，球员之间的工资差距越来越大。的确，中国足球不缺恒大，上港这样的土豪，随手一挥就能与球员签下一笔天价合约，但这样的薪资，真的反映了球员间的真实水平吗？</p><p>同样，在这样的薪资水平背景下富裕的球队会吸引更多国内人才巩固实力，同样也会吸引高水平外援加盟进一步提升球队上限，而相对贫穷的球队为了保级只能顺应“潮流”，既然买不起大牌国脚，就只能通过给出离谱的工资来吸引大牌外援，以便更快更有效的提升球队实力保级。这样的正反馈无疑是不健康的，最终只会导致各家球队烧钱越来越多，军备竞赛越来越激烈，而这样的最终结果就是————球队不堪重负、欠薪丑闻爆出，甚至解散。而这恰恰就是近几年中国足球各级联赛出现次数越来越多的情况。再过去，一家球队解散似乎只限于低级别联赛。而这几年，辽宁，延边，天海，这些中超边缘的球队也开始出现这样的情况，甚至最近一些中超的球队也被爆出欠薪。如果这种烧钱的竞争继续进行下去，会不会有更多的球队出现这种“玩不起”的情况呢？</p><p>我们无法判断球员的薪资与其真实水平之间是否相匹配，也没有什么办法来判断球员拿到高薪是不是合理，只能通过我们主观的角度来批判这种现象，而这种批判丝毫无法影响土豪球队买人补强。如今足协颁布限薪令，则是从根本上为球队烧钱的行为套上了枷锁。我个人认为，这样的政策对中国足球的长远发展还是有益处的，但至于政策中的具体薪资是否合理，就只能够通过政策实施以后的实际情况来看了。</p><p>有利必有弊，虽然从工资上进行限制，可以从根本上杜绝中国足球不健康的工资结构，但砍掉最高工资之后，重新构建的工资体系又是否健康呢？这样的政策是否会导致低级别联赛的球员工资再进一步降低，乃至影响球员积极性，导致人才流失的情况呢？这些事我们就无法预测了，也只能看看未来会是什么样了。</p><p>同样的，对于外援的限薪令则是给目前的联赛来了一记重拳。这势必会导致各队的大牌外援纷纷离开，之后各家球队只能选择性价比更高的外援。这点我认为还是无需太过担忧的，毕竟十年前的中超联赛也并没有多少世界级外援，而各家球队也能玩的非常开心，即使在今天，也有许多名气不算出众，但用实力为自己正名的外援在中超赛场活跃着。不可否认，大牌外援为中超带来了许多关注度，也让中超球队在亚冠赛场上拥有了更强的竞争力，但经过这么多年来看，似乎大牌外援并没有对国内球员带来多少提高，即便是里皮这样的名帅，带了国足之后也只落得一个晚节不保。所以，对于未来中超联赛各队的外援之争，我还是非常期待的。（不期待亚泰再买金银角大王这样的球员）</p><p>另外有一个我比较在意的事，那就是规划球员们以后的工资会怎么算，虽然说他们已经是中国人了，但真的会愿意接受这样的条款吗😏</p><h2 id="球队名中性化"><a href="#球队名中性化" class="headerlink" title="球队名中性化"></a>球队名中性化</h2><p>球队限薪令一出，球迷众说纷纭，但球队中性化这条政策一出，足协就遭到了广大球迷的口诛笔伐。因为这意味着几乎全中国职业联赛的球队都要改个名，像亚泰这样20多年如一日的球队，也要换个中性化的名字。如果说限薪令是着眼于当下，那么中性化无疑是足协着眼于未来的一步了。将现有球队球队名“地名+企业名”的形式改变，彻底删除企业的名称改为中姓名，这样有利于球迷文化建设，使一支球队长久的以所在地为根本，持续生存下去。</p><p>作为一名亚泰球迷，我可以理解足协的良苦用心，但实在无法支持自己喜爱的球队在刚刚冲上超级联赛，就面临更换名称这样的事情。毕竟，早在几年前足协的意见中，像亚泰，申花，国安，建业这样长久由一家企业运营的球队可以不用更改名称，而到了现在又要更改了，这种出尔反尔的行为让人难以接受。因为这几家球队在二十来年的历史中，早已自成一派，形成了独特的球迷团体和球队文化，在中国足球的历史上也留下了属于自己的名字，如今却除了申花都要更改名称了。</p><p>而对于足协来说想必推出这样的政策，就代表他们已经准备好得罪许多球队以及球迷。毕竟更改中姓名这件事，要不就都不改，要改就不能有特例留下。总之是一个谁都不讨好的政策。而目前一些球迷也对以后各球队的中姓名进行了讨论，好像也没有什么特别理想的名称。有些人提出像日本J联赛的一些球队，像大阪樱花，广岛三箭，鹿岛鹿角这样的名称就很好听，同时也有一定意义，可这些队名同样是存在数十年，在球迷之间一带一带流传下来才具有这样的意义的。如果突然给你来一个“东京铁塔”这样的队名，是不是感觉也有些别扭？回到我们的中超，如果各支球队队名都改成“长春人”、“上海人”、“北京人”这样的队名，我看还不如不改。</p><p>最后放一张亚泰16年保级最后一战面对上海申花时的一张图，当时亚泰1：0赢了比赛，顺利留在了中超联赛。现在放上这张图也没有什么特别的意思，只是感觉有些感慨。</p><p><img src="/images/yatai.jpg" class="lazyload" data-srcset="/images/yatai.jpg" srcset="data:image/png;base64,666" alt="yatai"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode121 买卖股票的最佳时机</title>
      <link href="2020/12/17/20201217-leetcode/"/>
      <url>2020/12/17/20201217-leetcode/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></li><li><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a> (与121相同)</li></ul><p>我在LeetCode买股票之利益最大化。</p><a id="more"></a><p>今天的LeetCode每日一题很有意思，看到股票，就想到我现在的实习，虽然跟买卖股票是没有太大关系了，这道题类似的题目之前也做过几道，而且很有意思。做完这道题后我又稍微复习了一下相关的所有问题，就把这些问题的解法写下来吧。</p><div class="note link green"><p>来源：力扣（LeetCode）链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></div><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line"></span><br><span class="line">注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>这道题目比较简单，因为只需要进行一次买卖，因此我们只需要在价格数组中找到按顺序的最小值，以及后面的最大值，这两个值的差值就是买卖股票获得的最大利润。我们可以使用动态规划的方法，维护两个值<code>maxprofit</code>和<code>minprice</code>，来保存最大的利润以及最小价格。在每次迭代中，<code>minprice = min(price[i], minprice)</code>，而<code>maxprofit = max(maxprofit, price[i] - minprice)</code>。通过对数组进行一次遍历，就可以得到最大的利润值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">int</span> minprice = inf, maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price: prices) &#123;</span><br><span class="line">            maxprofit = max(maxprofit, price - minprice);</span><br><span class="line">            minprice = min(price, minprice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>这道题与上一道非常相似，不同之处在于可以进行多次买卖，甚至可以当天买入，当天卖出。但同时，个人手中不可以持有多只股票。这样，我们可以根据手中股票的状态来进行动态规划。我们可以假设<code>dp0</code>代表手中没有股票时，买卖股票所得到总利润，<code>dp1</code>代表手中持有一只股票时，买卖股票所得的总利润，类似上一道题，继续使用动态规划的方法。</p><p>我们可以得到<code>dp0[n] = max(dp0[n - 1], dp1[n - 1] + prices[i])</code>。我们当前手中没有股票，那么可能我们在上一天手中也没有股票，或者上一天将手中的股票卖了出去。</p><p>同样，可以得到<code>dp1[n] = max(dp1[n - 1], dp0[n - 1] - prices[i])</code>。如果我们手中有股票，那么可能我们在上一天也持有该股票，或者上一天刚刚买入该股票。</p><p>这样，我们再次对于数组进行一次遍历，就能得到能得到的最大利润。由于dp1肯定比dp0小（最后一天所处的状态一定是手中没有股票的，这样才能收回买卖股票所得的全部本金及利润。），所以我们直接返回dp0。</p><p>值得一提的是，因为我们在每次迭代中，只用到了dp1[n], dp0[n], dp1[n - 1], dp0[n - 1]这四个值，所以我们可以使用四个int常亮保存这四个值，这样可以节省一定的空间。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">int</span> dp00 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp11 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp0 = dp00, dp1 = dp11;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)&#123;</span><br><span class="line">            dp0 = max(dp00, dp11 + prices[i]);</span><br><span class="line">            dp1 = max(dp11, dp00 - prices[i]);</span><br><span class="line">            dp00 = dp0;</span><br><span class="line">            dp11 = dp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="另一个办法"><a href="#另一个办法" class="headerlink" title="另一个办法"></a>另一个办法</h3><p>其实，这道题还可以有另一种巧妙的解法。由于题目没有限制买卖的次数，我们可以用一种贪心的策略，即细分到每一天考虑，如果第二天的股票价格比第一天价格高，那就执行“第一天买，第二天卖”的策略，这样只要股票价格有上涨的趋势，那我们就一定能买到所有上涨的股票。（我还不太会具体的证明）。</p><p>换一句话说，将股票的价格画成一个折线图，我们要找的就是折线图中所有上升的区间。</p><p>于是这样再写代码就容易多了，只需要每天进行判断就可以了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i + <span class="number">1</span>] &gt; prices[i])&#123;</span><br><span class="line">                profit += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a>309. 最佳买卖股票时机含冷冻期</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>这道题同样也是买卖股票，在上一道题的基础上，增加了冷冻期这一概念。说到底，只是相当于在动态规划中再次添加一个状态，也就是处于冷冻期的状态。这样就很好理解了。我第一次看到这个题时，还想了大半天怎么在上一道题的两个状态上加上各种限制，其实都不如再加上另一个状态省事。我们加上第三个状态<code>dp10</code>，代表此时正处于冷却期。则：<code>dp10[i] = dp1[i - 1] + prices[i];</code>， 如果要进入冷却期，则上一天一定持有股票，并在这天卖掉了股票。<br>其余的状态与上一道题类似。</p><p>我们再进行一次遍历，获得最后的利润。由于我们最后的状态可以是在冷却期，或是不持有股票也不在冷却期。所以我们要取<code>dp0</code>与<code>dp10</code>的最大值。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp0[n], dp1[n], dp10[n];</span><br><span class="line">        dp0[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp1[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp10[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp0[i] = max(dp0[i - <span class="number">1</span>], dp10[i - <span class="number">1</span>]);</span><br><span class="line">            dp1[i] = max(dp0[i - <span class="number">1</span>] - prices[i], dp1[i - <span class="number">1</span>]);</span><br><span class="line">            dp10[i] = dp1[i - <span class="number">1</span>] + prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp0[n - <span class="number">1</span>], dp10[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a>714. 买卖股票的最佳时机含手续费</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出: 8</span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</span><br></pre></td></tr></table></figure><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>这道题也是在122的基础上，添加了<strong>手续费</strong>的概念，每次交易都需要支付一定手续费，这样我们可以直接在122的基础上，为每次交易添加上手续费。然后一次遍历就能得到答案了。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">int</span> dp0[n], dp1[n];</span><br><span class="line">        dp0[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp1[<span class="number">0</span>] = -prices[<span class="number">0</span>] - fee;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)&#123;</span><br><span class="line">            dp0[i] = max(dp0[i - <span class="number">1</span>], dp1[i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp1[i] = max(dp1[i - <span class="number">1</span>], dp0[i - <span class="number">1</span>] - prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网开发学习路线整理</title>
      <link href="2020/12/14/20201214-learn/"/>
      <url>2020/12/14/20201214-learn/</url>
      
        <content type="html"><![CDATA[<h2 id="学习网址与APP"><a href="#学习网址与APP" class="headerlink" title="学习网址与APP"></a>学习网址与APP</h2><p>手机APP-慕课网：各种方面的课程，入门学习（偏基础，了解）<br>网站-<a href="https://search.jikexueyuan.com/course/?q=aws">极客学院</a>：各种方面教程，Docker，AWS教程（较深入，重点学习）<br>网站-<a href="http://www.java1234.com/">Java知识分享网</a>：Java全面教程，<strong>重点</strong>：第八阶段Dubbo&amp;Springcloud教程<br>网站-<a href="https://www.aliyun.com/">阿里云</a>：上面有各种类型的教程，可以学习使用</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>HTML, CSS, H5, JS等等基础。。。<br>框架： Vue国内比较多， Facebook的React，从Vue和react衍生出的Weex和React Native（RN）。<br>移动端开发<br>开源的：ElementUI，ant。。。。<br>公司使用：uniapp开源框架，可以生成八种平台（iOS，Android，微信，支付宝，抖音。。。。。）<br>基础中的基础：node.js</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>Web Services<br>Kafka,<br>数据库：。。。<br>restful -&gt; -&gt; SpringMVC -&gt; SpringBoot -&gt; SpringCloud<br>    HSF -&gt; dubbo-&gt; RPC</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>Hadoop -&gt; 分布式计算：MapReduce<br>          分布式存储：hdfs      -&gt;   Hive  -&gt;   sql/nosql<br>块？数据Spark<br>流数据：Storm  sparksql  Flink  </p><p>nosql: redis, mongodb,<br>        lucene -&gt; elastic search    类似于搜索引擎</p><p>图数据库：通过图的方式构建关系</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>总体上来说，哪里出现问题就从哪里进行改变<br>看各种架构历史演变的帖子<br>Tomcat&amp;db -&gt; 分离 -&gt;db分离 -&gt; db再进行修改。。。<br>          -&gt; ？？4层 -&gt; nginx 7层 -&gt; 。。。<br>-&gt; Hadoop。。。。。<br>书 阿里中台战略<br>理解中台的概念</p><h2 id="金融科技"><a href="#金融科技" class="headerlink" title="金融科技"></a>金融科技</h2><h3 id="云"><a href="#云" class="headerlink" title="云"></a>云</h3><p>公有云： 阿里，腾讯，AWS，。。。学习使用<br>4种层次，最低端代码操作 - SDK - CLI - 图形界面 理解API的意义，restful相关</p><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><h3 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h3><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>可以自己建立私链尝试。。。solidity web3.js 以太坊应用？。。</p><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>机器学习：Python -&gt; sklearn。。。。。<br>深度学习：TF &amp; Keras 使用率最高</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Docker &amp; KS8</p>]]></content>
      
      
      
        <tags>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode102 二叉树的层序遍历</title>
      <link href="2020/12/14/20201214-leetcode/"/>
      <url>2020/12/14/20201214-leetcode/</url>
      
        <content type="html"><![CDATA[<p>RT，二叉树的层序遍历</p><a id="more"></a><p>今天上午刷LeetCode心态崩了，啥题都写不出来，索性来写博客，记录一下做过的题。</p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">LeetCode102.二叉树的层序遍历</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）</p><p><strong>示例</strong>：二叉树：[3,9,20,null,null,15,7],</p><p>返回其层次遍历结果：[[3],  [9,20],  [15,7]]</p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>在这道题之前我曾经做过二叉树的前中后序遍历等问题，于是一上来想到的就是各种递归的方法，但是百思不得其解。查看答案才发现自己一开始的思路就错了，原来层序遍历与前中后序遍历使用了完全不一样的方法。</p><p>这道题中我们运用了 <strong>广度优先遍历（BFS）</strong> 的方法来解决问题，每次遍历二叉树中一层的元素，然后再接着遍历下一层。</p><p>要解决这个问题我们需要用到队列这一数据结构，由于队列具有先入先出的性质，我们每次将遍历到的一层节点压入队列，然后对这些节点进行处理，将这一层节点的子节点压入队列，然后让这一层的节点出队列，再接着处理下一层的节点。</p><p>另外一个让我思考的点是，如何在输出的数组中，确定同一层的节点个数。这一问题比较好解决，因为在将一层的节点全部压入队列并处理之前，已经将上一层的节点全部弹出，所以可以在处理每层节点之前先计算这层节点的数量，然后用这个数量值作为限制处理该层的节点就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用了两种方法来写代码，一种似乎是参考答案写的，每一层直接进行处理，另一种是我第二次复习时候写的，在处理每一层时新建了一个vector存储每一层的节点，然后再处理结束后将vector加入到答案vector中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">int</span> size=q.size();            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">                TreeNode* node=q.front();</span><br><span class="line">                result.back().push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)q.push(node-&gt;right);</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;level;            </span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;                </span><br><span class="line">                level.push_back(q.front()-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q.front()-&gt;left)q.push(q.front()-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(q.front()-&gt;right)q.push(q.front()-&gt;right);</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二叉树的层序遍历作为广度优先遍历的基础，让我理解了bfs这一算法的基本框架，后面还需要再好好学习一下这一方面，毕竟都忘得差不多了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volantis主题设置学习日记</title>
      <link href="2020/12/11/Volantis%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2020/12/11/Volantis%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>这是我的Volantis主题设置学习日记，主要包括我在使用Volantis过程中遇到的疑难杂症以及一些细节问题。文中所有内容以<a href="https://volantis.js.org/getting-started/">Volantis官方文档</a>为准。</p><a id="more"></a><h2 id="Volantis图标设计"><a href="#Volantis图标设计" class="headerlink" title="Volantis图标设计"></a>Volantis图标设计</h2><h3 id="使用Font-Awesome预设图标"><a href="#使用Font-Awesome预设图标" class="headerlink" title="使用Font Awesome预设图标"></a>使用Font Awesome预设图标</h3><p>在hexo-themes-volantis这个文件夹下的_config.yml中，我找到了Volantis主题配置的一些代码，其中，很多图标都是由<code>fas fa-envelope</code>或者<code>fas fa-envelope</code>显示的，比如在博客作者logo下显示的作者联系方式，微博推特等链接的图标：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line"><span class="bullet">        -</span> icon: fab fa-facebook</span><br><span class="line"><span class="code">          url: https://www.facebook.com/jingtong.xu.779</span></span><br><span class="line"><span class="code">        - icon: fas fa-envelope</span></span><br><span class="line"><span class="code">          url: mailto:xjt980408@163.com</span></span><br><span class="line"><span class="code">        - icon: fab fa-weixin</span></span><br><span class="line"><span class="code">          url: https://www.instagram.com/xjtcoco/</span></span><br><span class="line"><span class="code">        - icon: fab fa-instagram-square</span></span><br><span class="line"><span class="code">          url: https://www.instagram.com/xjtcoco/</span></span><br></pre></td></tr></table></figure><p>最开始我完全不知道这些代码的意义，但经过一番搜索，终于在这些图标的名称这一点上找到了突破，这些图标都是由一个名为Font Awesome的图标网站设计的，而在每个<strong>index.html</strong>文件的头部，都会通过一个js函数导入这些图标。在<a href="https://fa5.dashgame.com/#/%E5%9B%BE%E6%A0%87">Font Awesome官方网站</a>中，可以查到最新的Font Awesome图标的代码。而<a href="http://www.fontawesome.com.cn/faicons/">Font Awesome中文网</a>也可以查到图标的种类（下面会说）。</p><p>然而，当我想要修改这些图标时，又遇到了麻烦，我想要在我的logo下面加入Facebook，微信和Instagram的图标作为链接，但是我将每个icon后面的图标代码修改为相应的图标代码后，重新生成页面，图标竟然无法显示。我认为，这一问题主要是由于代码前的一个代号，比如邮件的<code>fas fa-envelope</code>前有一个<br><code>fas</code>，而<code>fab fa-weixin</code>前的代号却是<code>fab</code>，这两者之间的区别究竟代表什么意义呢？</p><p>又经历了<a href="https://www.jianshu.com/p/db29ac8b6580">一番搜索</a>后，我终于明白了<code>fas</code>与<code>fab</code>的区别。这是由Font Awesome的新特性引起的，原来的图标前缀<code>fa</code>被更改了为<code>fas</code>，<code>fab</code>与<code>far</code>，具体哪个图标属于哪一个种类可以由上面的官网链接查看。其中，<code>fas</code>代表实心图标，而<code>fab</code>代表品牌图标，这就可以解释为什么我使用<code>fas fa-nstagram</code>，而在网站上无法显示的问题了。</p><h3 id="使用图片作为图标"><a href="#使用图片作为图标" class="headerlink" title="使用图片作为图标"></a>使用图片作为图标</h3><p>这是我通过实验多次未果，最后百度搜索得到的结果，Hexo默认的文件位置在 <strong>/blog/source</strong> 文件目录下，因此如果在<strong>source</strong>文件夹下新建了一个<strong>images</strong>文件夹用来存放所有博客需要的图片文件，并使用<strong>rowlet.png</strong>作为我的头像（没错，就是左边那只可爱的木木枭！），那么我需要在<strong>_config.volantis.yml</strong>中的<strong>sidebar</strong>项<strong>widget_library</strong>项中的avatar设置为<code>/images/rowlet.png</code>，这样就可以找到正确的文件路径了。然后就可以惊喜的发现，我的头像变成了一只可爱的木木枭！<img src="/images/rowlet.png" class="lazyload" data-srcset="/images/rowlet.png" srcset="data:image/png;base64,666" alt="木呼"></p><h2 id="网站统计"><a href="#网站统计" class="headerlink" title="网站统计"></a>网站统计</h2><p>对于博客来说，我们可以统计一下网站的总访问量以及访问次数，Volantis很方便地集成了这些功能，只不过需要自己再手动配置一些选项才能正确使用。主页的“站点信息”widget，其中有一个选项<strong>visitcounter</strong>中的<strong>service</strong>，将这一项从<code>leancloud</code>改成<code>busuanzi</code>就可以使用不蒜子的网页统计功能了，十分方便，而如果要使用leancloud的话或许需要再申请之类的，我还是觉得不蒜子的更方便一些。</p><p>当然，方便有方便的问题。在网页底部的相关信息也需要修改，这部分的配置文件在<strong>site_footer</strong>中的<strong>analytics</strong>中。这一部分的具体原理我没有太明白，因为默认使用的是leancloud的服务，所以显示数据与实际不符。我在F12检查网页源代码后，发现这一部分直接使用html代码进行配置，而两个span的id均是leancloud的id，于是我参考webbinfo中的设置，将spanid改成了busuanzi的形式，然后根据实际效果，将span内的字段移到了span外，这回似乎可以用了，如果你看到这里，可以将网页拉到最下面看一看，那里的统计数据是否正确加载，是否与首页的统计数据是否一致。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本站总访问量为<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&#x27;number&#x27;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-circle-notch fa-spin fa-fw&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>次</span><br><span class="line">访客数为<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&#x27;number&#x27;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-circle-notch fa-spin fa-fw&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>人 </span><br></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="文章中的注释"><a href="#文章中的注释" class="headerlink" title="文章中的注释"></a>文章中的注释</h3><p>在12月11日的版本中，我将写完的文章部署到GitHub上后，发现这篇文章的评论区以及侧边栏都没有正确加载出来，我开始是以为这是因为GitHub的网络延迟而导致的，可是在刷新了几遍之后问题依旧存在，这一个周末都没有怎么搞博客，也没有继续管这个问题。12月14日早晨，终于在调试了几次之后发现了玄机。<br>原来的文章中有一大段<strong>注释</strong>，本来是我想在之后写下来的内容，因为没有写完而被注释掉了，在我删除了这段注释之后在使用<code>hexo g &amp;&amp; hexo s</code>生成后，显示的页面就不再有问题了。</p><p>但是，在我再次在文章的某一段落加上注释之后，同样的问题就不再生成了，所以可能也并不是注释引起的问题。。。😂</p><p>整了一上午，终于整明白了，之后还可以再搞搞别的，比如文章作者，最后修改时间等问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Volantis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-12-10:a New Article</title>
      <link href="2020/12/10/2020-12-10-a-new-article/"/>
      <url>2020/12/10/2020-12-10-a-new-article/</url>
      
        <content type="html"><![CDATA[<h3 id="This-is-a-new-article"><a href="#This-is-a-new-article" class="headerlink" title="This is a new article"></a>This is a new article</h3><hr><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p><strong>RUNOOB.COM</strong><br><em>GOOGLE.COM</em><br><del>BAIDU.COM</del></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇Markdown博客☝</title>
      <link href="2020/12/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Markdown%E5%8D%9A%E5%AE%A2%E2%98%9D/"/>
      <url>2020/12/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Markdown%E5%8D%9A%E5%AE%A2%E2%98%9D/</url>
      
        <content type="html"><![CDATA[<p>这是我使用markdown语法写的第一篇博客，其中主要目的是测试markdown语法的各种功能以及写一些以后可以在这个博客中继续学习的方面。</p><a id="more"></a><hr><p>Markdown的语法非常简单，似乎只需要通过几种格式就可以让文本变得更加生动。<br>我要不要把这些方式全部记录下？<br>算了，还是留下一个连接方便查阅<a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics?id=%e8%af%ad%e6%b3%95%e8%af%b4%e6%98%8e">Markdown语法</a>比较好。<br>接下来是一些测试环节，如果你不知道我在写什么，那就对了。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h1 id="哈"><a href="#哈" class="headerlink" title="哈"></a>哈</h1><h2 id="哈哈"><a href="#哈哈" class="headerlink" title="哈哈"></a>哈哈</h2><h3 id="哈哈哈"><a href="#哈哈哈" class="headerlink" title="哈哈哈"></a>哈哈哈</h3><h4 id="哈哈哈哈"><a href="#哈哈哈哈" class="headerlink" title="哈哈哈哈"></a>哈哈哈哈</h4><h5 id="哈哈哈哈哈"><a href="#哈哈哈哈哈" class="headerlink" title="哈哈哈哈哈"></a>哈哈哈哈哈</h5><h6 id="哈哈哈哈哈哈"><a href="#哈哈哈哈哈哈" class="headerlink" title="哈哈哈哈哈哈"></a>哈哈哈哈哈哈</h6><p>####### 哈哈哈哈哈哈哈 </p><p>Markdown最多只支持六级标题，七级就太多了。<br>卧槽，写这么多哈，我连这个字都不认识了。</p><h2 id="各种奇妙类型的文字"><a href="#各种奇妙类型的文字" class="headerlink" title="各种奇妙类型的文字"></a>各种奇妙类型的文字</h2><p><u>带下划线的文本</u></p><p><em>这会是 斜体 的文字</em><br><em>这会是 斜体 的文字</em></p><p><strong>这会是 粗体 的文字</strong><br><strong>这会是 粗体 的文字</strong></p><p><em>你也 <strong>组合</strong> 这些符号</em></p><p><del>这个文字将会被横线删除</del></p><!-- 创建脚注格式类似这样 [^RUNOOB]。[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！ --><p>sadasdssafassadasdasdsa<br>富豪排队静安寺欧弟和以为广大千万i<br>###This is a new article</p><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言代码</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello world!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--markdown语法--&gt;</span><br><span class="line">https://github.com - 自动生成！</span><br><span class="line">[<span class="string">GitHub</span>](<span class="link">https://github.com</span>)</span><br></pre></td></tr></table></figure><p>😄</p><!-- LeetCode模板 --><!--more--><!-- ## XXX. XXXX### 题目描述### 题目解析### 代码 -->]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/12/10/hello-world/"/>
      <url>2020/12/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
