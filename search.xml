<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode121 买卖股票的最佳时机</title>
      <link href="2020/12/17/20201217-leetcode/"/>
      <url>2020/12/17/20201217-leetcode/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></li><li><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a> (与121相同)</li></ul><p>我在LeetCode买股票之利益最大化。</p><a id="more"></a><p>今天的LeetCode每日一题很有意思，看到股票，就想到我现在的实习，虽然跟买卖股票是没有太大关系了，这道题类似的题目之前也做过几道，而且很有意思。做完这道题后我又稍微复习了一下相关的所有问题，就把这些问题的解法写下来吧。</p><div class="note link green"><p>来源：力扣（LeetCode）链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E9%A2%86%E6%89%A3%E7%BD%91%E7%BB%9C%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E5%AE%98%E6%96%B9%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</a></p></div><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line"></span><br><span class="line">注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>这道题目比较简单，因为只需要进行一次买卖，因此我们只需要在价格数组中找到按顺序的最小值，以及后面的最大值，这两个值的差值就是买卖股票获得的最大利润。我们可以使用动态规划的方法，维护两个值<code>maxprofit</code>和<code>minprice</code>，来保存最大的利润以及最小价格。在每次迭代中，<code>minprice = min(price[i], minprice)</code>，而<code>maxprofit = max(maxprofit, price[i] - minprice)</code>。通过对数组进行一次遍历，就可以得到最大的利润值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">int</span> minprice = inf, maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price: prices) &#123;</span><br><span class="line">            maxprofit = max(maxprofit, price - minprice);</span><br><span class="line">            minprice = min(price, minprice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>这道题与上一道非常相似，不同之处在于可以进行多次买卖，甚至可以当天买入，当天卖出。但同时，个人手中不可以持有多只股票。这样，我们可以根据手中股票的状态来进行动态规划。我们可以假设<code>dp0</code>代表手中没有股票时，买卖股票所得到总利润，<code>dp1</code>代表手中持有一只股票时，买卖股票所得的总利润，类似上一道题，继续使用动态规划的方法。</p><p>我们可以得到<code>dp0[n] = max(dp0[n - 1], dp1[n - 1] + prices[i])</code>。我们当前手中没有股票，那么可能我们在上一天手中也没有股票，或者上一天将手中的股票卖了出去。</p><p>同样，可以得到<code>dp1[n] = max(dp1[n - 1], dp0[n - 1] - prices[i])</code>。如果我们手中有股票，那么可能我们在上一天也持有该股票，或者上一天刚刚买入该股票。</p><p>这样，我们再次对于数组进行一次遍历，就能得到能得到的最大利润。由于dp1肯定比dp0小（最后一天所处的状态一定是手中没有股票的，这样才能收回买卖股票所得的全部本金及利润。），所以我们直接返回dp0。</p><p>值得一提的是，因为我们在每次迭代中，只用到了dp1[n], dp0[n], dp1[n - 1], dp0[n - 1]这四个值，所以我们可以使用四个int常亮保存这四个值，这样可以节省一定的空间。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">int</span> dp00 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp11 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp0 = dp00, dp1 = dp11;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)&#123;</span><br><span class="line">            dp0 = max(dp00, dp11 + prices[i]);</span><br><span class="line">            dp1 = max(dp11, dp00 - prices[i]);</span><br><span class="line">            dp00 = dp0;</span><br><span class="line">            dp11 = dp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="另一个办法"><a href="#另一个办法" class="headerlink" title="另一个办法"></a>另一个办法</h3><p>其实，这道题还可以有另一种巧妙的解法。由于题目没有限制买卖的次数，我们可以用一种贪心的策略，即细分到每一天考虑，如果第二天的股票价格比第一天价格高，那就执行“第一天买，第二天卖”的策略，这样只要股票价格有上涨的趋势，那我们就一定能买到所有上涨的股票。（我还不太会具体的证明）。</p><p>换一句话说，将股票的价格画成一个折线图，我们要找的就是折线图中所有上升的区间。</p><p>于是这样再写代码就容易多了，只需要每天进行判断就可以了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i + <span class="number">1</span>] &gt; prices[i])&#123;</span><br><span class="line">                profit += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a>309. 最佳买卖股票时机含冷冻期</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>这道题同样也是买卖股票，在上一道题的基础上，增加了冷冻期这一概念。说到底，只是相当于在动态规划中再次添加一个状态，也就是处于冷冻期的状态。这样就很好理解了。我第一次看到这个题时，还想了大半天怎么在上一道题的两个状态上加上各种限制，其实都不如再加上另一个状态省事。我们加上第三个状态<code>dp10</code>，代表此时正处于冷却期。则：<code>dp10[i] = dp1[i - 1] + prices[i];</code>， 如果要进入冷却期，则上一天一定持有股票，并在这天卖掉了股票。<br>其余的状态与上一道题类似。</p><p>我们再进行一次遍历，获得最后的利润。由于我们最后的状态可以是在冷却期，或是不持有股票也不在冷却期。所以我们要取<code>dp0</code>与<code>dp10</code>的最大值。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp0[n], dp1[n], dp10[n];</span><br><span class="line">        dp0[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp1[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp10[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp0[i] = max(dp0[i - <span class="number">1</span>], dp10[i - <span class="number">1</span>]);</span><br><span class="line">            dp1[i] = max(dp0[i - <span class="number">1</span>] - prices[i], dp1[i - <span class="number">1</span>]);</span><br><span class="line">            dp10[i] = dp1[i - <span class="number">1</span>] + prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp0[n - <span class="number">1</span>], dp10[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a>714. 买卖股票的最佳时机含手续费</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出: 8</span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</span><br></pre></td></tr></table></figure><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>这道题也是在122的基础上，添加了<strong>手续费</strong>的概念，每次交易都需要支付一定手续费，这样我们可以直接在122的基础上，为每次交易添加上手续费。然后一次遍历就能得到答案了。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">int</span> dp0[n], dp1[n];</span><br><span class="line">        dp0[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp1[<span class="number">0</span>] = -prices[<span class="number">0</span>] - fee;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)&#123;</span><br><span class="line">            dp0[i] = max(dp0[i - <span class="number">1</span>], dp1[i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp1[i] = max(dp1[i - <span class="number">1</span>], dp0[i - <span class="number">1</span>] - prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网开发学习路线整理</title>
      <link href="2020/12/14/20201214-learn/"/>
      <url>2020/12/14/20201214-learn/</url>
      
        <content type="html"><![CDATA[<h2 id="学习网址与APP"><a href="#学习网址与APP" class="headerlink" title="学习网址与APP"></a>学习网址与APP</h2><p>手机APP-慕课网：各种方面的课程，入门学习（偏基础，了解）<br>网站-<a href="https://search.jikexueyuan.com/course/?q=aws">极客学院</a>：各种方面教程，Docker，AWS教程（较深入，重点学习）<br>网站-<a href="http://www.java1234.com/">Java知识分享网</a>：Java全面教程，<strong>重点</strong>：第八阶段Dubbo&amp;Springcloud教程<br>网站-<a href="https://www.aliyun.com/">阿里云</a>：上面有各种类型的教程，可以学习使用</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>HTML, CSS, H5, JS等等基础。。。<br>框架： Vue国内比较多， Facebook的React，从Vue和react衍生出的Weex和React Native（RN）。<br>移动端开发<br>开源的：ElementUI，ant。。。。<br>公司使用：uniapp开源框架，可以生成八种平台（iOS，Android，微信，支付宝，抖音。。。。。）<br>基础中的基础：node.js</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>Web Services<br>Kafka,<br>数据库：。。。<br>restful -&gt; -&gt; SpringMVC -&gt; SpringBoot -&gt; SpringCloud<br>    HSF -&gt; dubbo-&gt; RPC</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>Hadoop -&gt; 分布式计算：MapReduce<br>          分布式存储：hdfs      -&gt;   Hive  -&gt;   sql/nosql<br>块？数据Spark<br>流数据：Storm  sparksql  Flink  </p><p>nosql: redis, mongodb,<br>        lucene -&gt; elastic search    类似于搜索引擎</p><p>图数据库：通过图的方式构建关系</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>总体上来说，哪里出现问题就从哪里进行改变<br>看各种架构历史演变的帖子<br>Tomcat&amp;db -&gt; 分离 -&gt;db分离 -&gt; db再进行修改。。。<br>          -&gt; ？？4层 -&gt; nginx 7层 -&gt; 。。。<br>-&gt; Hadoop。。。。。<br>书 阿里中台战略<br>理解中台的概念</p><h2 id="金融科技"><a href="#金融科技" class="headerlink" title="金融科技"></a>金融科技</h2><h3 id="云"><a href="#云" class="headerlink" title="云"></a>云</h3><p>公有云： 阿里，腾讯，AWS，。。。学习使用<br>4种层次，最低端代码操作 - SDK - CLI - 图形界面 理解API的意义，restful相关</p><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><h3 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h3><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>可以自己建立私链尝试。。。solidity web3.js 以太坊应用？。。</p><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>机器学习：Python -&gt; sklearn。。。。。<br>深度学习：TF &amp; Keras 使用率最高</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Docker &amp; KS8</p>]]></content>
      
      
      
        <tags>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode102 二叉树的层序遍历</title>
      <link href="2020/12/14/20201214-leetcode/"/>
      <url>2020/12/14/20201214-leetcode/</url>
      
        <content type="html"><![CDATA[<p>RT，二叉树的层序遍历</p><a id="more"></a><p>今天上午刷LeetCode心态崩了，啥题都写不出来，索性来写博客，记录一下做过的题。</p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">LeetCode102.二叉树的层序遍历</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）</p><p><strong>示例</strong>：二叉树：[3,9,20,null,null,15,7],</p><p>返回其层次遍历结果：[[3],  [9,20],  [15,7]]</p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>在这道题之前我曾经做过二叉树的前中后序遍历等问题，于是一上来想到的就是各种递归的方法，但是百思不得其解。查看答案才发现自己一开始的思路就错了，原来层序遍历与前中后序遍历使用了完全不一样的方法。</p><p>这道题中我们运用了 <strong>广度优先遍历（BFS）</strong> 的方法来解决问题，每次遍历二叉树中一层的元素，然后再接着遍历下一层。</p><p>要解决这个问题我们需要用到队列这一数据结构，由于队列具有先入先出的性质，我们每次将遍历到的一层节点压入队列，然后对这些节点进行处理，将这一层节点的子节点压入队列，然后让这一层的节点出队列，再接着处理下一层的节点。</p><p>另外一个让我思考的点是，如何在输出的数组中，确定同一层的节点个数。这一问题比较好解决，因为在将一层的节点全部压入队列并处理之前，已经将上一层的节点全部弹出，所以可以在处理每层节点之前先计算这层节点的数量，然后用这个数量值作为限制处理该层的节点就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用了两种方法来写代码，一种似乎是参考答案写的，每一层直接进行处理，另一种是我第二次复习时候写的，在处理每一层时新建了一个vector存储每一层的节点，然后再处理结束后将vector加入到答案vector中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">int</span> size=q.size();            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">                TreeNode* node=q.front();</span><br><span class="line">                result.back().push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)q.push(node-&gt;right);</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;level;            </span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;                </span><br><span class="line">                level.push_back(q.front()-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q.front()-&gt;left)q.push(q.front()-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(q.front()-&gt;right)q.push(q.front()-&gt;right);</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二叉树的层序遍历作为广度优先遍历的基础，让我理解了bfs这一算法的基本框架，后面还需要再好好学习一下这一方面，毕竟都忘得差不多了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volantis主题设置学习日记</title>
      <link href="2020/12/11/Volantis%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
      <url>2020/12/11/Volantis%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>这是我的Volantis主题设置学习日记，主要包括我在使用Volantis过程中遇到的疑难杂症以及一些细节问题。文中所有内容以<a href="https://volantis.js.org/getting-started/">Volantis官方文档</a>为准。</p><a id="more"></a><h2 id="Volantis图标设计"><a href="#Volantis图标设计" class="headerlink" title="Volantis图标设计"></a>Volantis图标设计</h2><h3 id="使用Font-Awesome预设图标"><a href="#使用Font-Awesome预设图标" class="headerlink" title="使用Font Awesome预设图标"></a>使用Font Awesome预设图标</h3><p>在hexo-themes-volantis这个文件夹下的_config.yml中，我找到了Volantis主题配置的一些代码，其中，很多图标都是由<code>fas fa-envelope</code>或者<code>fas fa-envelope</code>显示的，比如在博客作者logo下显示的作者联系方式，微博推特等链接的图标：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line"><span class="bullet">        -</span> icon: fab fa-facebook</span><br><span class="line"><span class="code">          url: https://www.facebook.com/jingtong.xu.779</span></span><br><span class="line"><span class="code">        - icon: fas fa-envelope</span></span><br><span class="line"><span class="code">          url: mailto:xjt980408@163.com</span></span><br><span class="line"><span class="code">        - icon: fab fa-weixin</span></span><br><span class="line"><span class="code">          url: https://www.instagram.com/xjtcoco/</span></span><br><span class="line"><span class="code">        - icon: fab fa-instagram-square</span></span><br><span class="line"><span class="code">          url: https://www.instagram.com/xjtcoco/</span></span><br></pre></td></tr></table></figure><p>最开始我完全不知道这些代码的意义，但经过一番搜索，终于在这些图标的名称这一点上找到了突破，这些图标都是由一个名为Font Awesome的图标网站设计的，而在每个<strong>index.html</strong>文件的头部，都会通过一个js函数导入这些图标。在<a href="https://fa5.dashgame.com/#/%E5%9B%BE%E6%A0%87">Font Awesome官方网站</a>中，可以查到最新的Font Awesome图标的代码。而<a href="http://www.fontawesome.com.cn/faicons/">Font Awesome中文网</a>也可以查到图标的种类（下面会说）。</p><p>然而，当我想要修改这些图标时，又遇到了麻烦，我想要在我的logo下面加入Facebook，微信和Instagram的图标作为链接，但是我将每个icon后面的图标代码修改为相应的图标代码后，重新生成页面，图标竟然无法显示。我认为，这一问题主要是由于代码前的一个代号，比如邮件的<code>fas fa-envelope</code>前有一个<br><code>fas</code>，而<code>fab fa-weixin</code>前的代号却是<code>fab</code>，这两者之间的区别究竟代表什么意义呢？</p><p>又经历了<a href="https://www.jianshu.com/p/db29ac8b6580">一番搜索</a>后，我终于明白了<code>fas</code>与<code>fab</code>的区别。这是由Font Awesome的新特性引起的，原来的图标前缀<code>fa</code>被更改了为<code>fas</code>，<code>fab</code>与<code>far</code>，具体哪个图标属于哪一个种类可以由上面的官网链接查看。其中，<code>fas</code>代表实心图标，而<code>fab</code>代表品牌图标，这就可以解释为什么我使用<code>fas fa-nstagram</code>，而在网站上无法显示的问题了。</p><h3 id="使用图片作为图标"><a href="#使用图片作为图标" class="headerlink" title="使用图片作为图标"></a>使用图片作为图标</h3><p>这是我通过实验多次未果，最后百度搜索得到的结果，Hexo默认的文件位置在 <strong>/blog/source</strong> 文件目录下，因此如果在<strong>source</strong>文件夹下新建了一个<strong>images</strong>文件夹用来存放所有博客需要的图片文件，并使用<strong>rowlet.png</strong>作为我的头像（没错，就是左边那只可爱的木木枭！），那么我需要在<strong>_config.volantis.yml</strong>中的<strong>sidebar</strong>项<strong>widget_library</strong>项中的avatar设置为<code>/images/rowlet.png</code>，这样就可以找到正确的文件路径了。然后就可以惊喜的发现，我的头像变成了一只可爱的木木枭！<img src="/images/rowlet.png" class="lazyload" data-srcset="/images/rowlet.png" srcset="data:image/png;base64,666" alt="木呼"></p><h2 id="网站统计"><a href="#网站统计" class="headerlink" title="网站统计"></a>网站统计</h2><p>对于博客来说，我们可以统计一下网站的总访问量以及访问次数，Volantis很方便地集成了这些功能，只不过需要自己再手动配置一些选项才能正确使用。主页的“站点信息”widget，其中有一个选项<strong>visitcounter</strong>中的<strong>service</strong>，将这一项从<code>leancloud</code>改成<code>busuanzi</code>就可以使用不蒜子的网页统计功能了，十分方便，而如果要使用leancloud的话或许需要再申请之类的，我还是觉得不蒜子的更方便一些。</p><p>当然，方便有方便的问题。在网页底部的相关信息也需要修改，这部分的配置文件在<strong>site_footer</strong>中的<strong>analytics</strong>中。这一部分的具体原理我没有太明白，因为默认使用的是leancloud的服务，所以显示数据与实际不符。我在F12检查网页源代码后，发现这一部分直接使用html代码进行配置，而两个span的id均是leancloud的id，于是我参考webbinfo中的设置，将spanid改成了busuanzi的形式，然后根据实际效果，将span内的字段移到了span外，这回似乎可以用了，如果你看到这里，可以将网页拉到最下面看一看，那里的统计数据是否正确加载，是否与首页的统计数据是否一致。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本站总访问量为<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&#x27;number&#x27;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-circle-notch fa-spin fa-fw&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>次</span><br><span class="line">访客数为<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&#x27;number&#x27;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-circle-notch fa-spin fa-fw&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>人 </span><br></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="文章中的注释"><a href="#文章中的注释" class="headerlink" title="文章中的注释"></a>文章中的注释</h3><p>在12月11日的版本中，我将写完的文章部署到GitHub上后，发现这篇文章的评论区以及侧边栏都没有正确加载出来，我开始是以为这是因为GitHub的网络延迟而导致的，可是在刷新了几遍之后问题依旧存在，这一个周末都没有怎么搞博客，也没有继续管这个问题。12月14日早晨，终于在调试了几次之后发现了玄机。<br>原来的文章中有一大段<strong>注释</strong>，本来是我想在之后写下来的内容，因为没有写完而被注释掉了，在我删除了这段注释之后在使用<code>hexo g &amp;&amp; hexo s</code>生成后，显示的页面就不再有问题了。</p><p>但是，在我再次在文章的某一段落加上注释之后，同样的问题就不再生成了，所以可能也并不是注释引起的问题。。。😂</p><p>整了一上午，终于整明白了，之后还可以再搞搞别的，比如文章作者，最后修改时间等问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Volantis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-12-10:a New Article</title>
      <link href="2020/12/10/2020-12-10-a-new-article/"/>
      <url>2020/12/10/2020-12-10-a-new-article/</url>
      
        <content type="html"><![CDATA[<h3 id="This-is-a-new-article"><a href="#This-is-a-new-article" class="headerlink" title="This is a new article"></a>This is a new article</h3><hr><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p><strong>RUNOOB.COM</strong><br><em>GOOGLE.COM</em><br><del>BAIDU.COM</del></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇Markdown博客☝</title>
      <link href="2020/12/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Markdown%E5%8D%9A%E5%AE%A2%E2%98%9D/"/>
      <url>2020/12/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Markdown%E5%8D%9A%E5%AE%A2%E2%98%9D/</url>
      
        <content type="html"><![CDATA[<p>这是我使用markdown语法写的第一篇博客，其中主要目的是测试markdown语法的各种功能以及写一些以后可以在这个博客中继续学习的方面。</p><hr><p>Markdown的语法非常简单，似乎只需要通过几种格式就可以让文本变得更加生动。<br>我要不要把这些方式全部记录下？<br>算了，还是留下一个连接方便查阅<a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics?id=%e8%af%ad%e6%b3%95%e8%af%b4%e6%98%8e">Markdown语法</a>比较好。<br>接下来是一些测试环节，如果你不知道我在写什么，那就对了。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h1 id="哈"><a href="#哈" class="headerlink" title="哈"></a>哈</h1><h2 id="哈哈"><a href="#哈哈" class="headerlink" title="哈哈"></a>哈哈</h2><h3 id="哈哈哈"><a href="#哈哈哈" class="headerlink" title="哈哈哈"></a>哈哈哈</h3><h4 id="哈哈哈哈"><a href="#哈哈哈哈" class="headerlink" title="哈哈哈哈"></a>哈哈哈哈</h4><h5 id="哈哈哈哈哈"><a href="#哈哈哈哈哈" class="headerlink" title="哈哈哈哈哈"></a>哈哈哈哈哈</h5><h6 id="哈哈哈哈哈哈"><a href="#哈哈哈哈哈哈" class="headerlink" title="哈哈哈哈哈哈"></a>哈哈哈哈哈哈</h6><p>####### 哈哈哈哈哈哈哈 </p><p>Markdown最多只支持六级标题，七级就太多了。<br>卧槽，写这么多哈，我连这个字都不认识了。</p><h2 id="各种奇妙类型的文字"><a href="#各种奇妙类型的文字" class="headerlink" title="各种奇妙类型的文字"></a>各种奇妙类型的文字</h2><p><u>带下划线的文本</u></p><p><em>这会是 斜体 的文字</em><br><em>这会是 斜体 的文字</em></p><p><strong>这会是 粗体 的文字</strong><br><strong>这会是 粗体 的文字</strong></p><p><em>你也 <strong>组合</strong> 这些符号</em></p><p><del>这个文字将会被横线删除</del></p><!-- 创建脚注格式类似这样 [^RUNOOB]。[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！ --><p>sadasdssafassadasdasdsa<br>富豪排队静安寺欧弟和以为广大千万i<br>###This is a new article</p><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言代码</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello world!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--markdown语法--&gt;</span><br><span class="line">https://github.com - 自动生成！</span><br><span class="line">[<span class="string">GitHub</span>](<span class="link">https://github.com</span>)</span><br></pre></td></tr></table></figure><p>😄</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/12/10/hello-world/"/>
      <url>2020/12/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
