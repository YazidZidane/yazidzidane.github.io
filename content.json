{"meta":{"title":"Ted Xu","subtitle":"My personal page.","description":"A simple website made by GitHub Pages, Hexo and Volantis theme.","author":"Ted Xu","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2020-12-15T07:17:41.274Z","updated":"2020-12-15T07:17:41.274Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-12-15T05:36:39.001Z","updated":"2020-12-15T05:36:39.001Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Hello World."},{"title":"我的朋友们","date":"2020-12-15T05:39:20.533Z","updated":"2020-12-15T05:39:20.533Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2020-12-15T05:38:17.208Z","updated":"2020-12-15T05:38:17.208Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-12-15T05:38:52.303Z","updated":"2020-12-15T05:38:52.303Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-12-15T05:37:07.176Z","updated":"2020-12-15T05:37:07.176Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面向对象设计的原则","slug":"20210422-sd","date":"2021-04-22T14:26:10.000Z","updated":"2021-04-22T14:32:22.299Z","comments":true,"path":"2021/04/22/20210422-sd/","link":"","permalink":"http://example.com/2021/04/22/20210422-sd/","excerpt":"今天在看面经的时候看到了一道问题：面向对象设计的原则。虽然学计算机这么多年，但我从来没有在设计原则这方面进行过学习，对于那些设计模式、MVC这样的东西更是一知半解，今天利用这个机会稍微学习一下。 这篇文章还没完成，内容是从下面的参考文章抄来的，具体还有待完善。","text":"今天在看面经的时候看到了一道问题：面向对象设计的原则。虽然学计算机这么多年，但我从来没有在设计原则这方面进行过学习，对于那些设计模式、MVC这样的东西更是一知半解，今天利用这个机会稍微学习一下。 这篇文章还没完成，内容是从下面的参考文章抄来的，具体还有待完善。 参考文章面向对象设计原则设计模式：面向对象设计的六大原则 (绝对详细) 1、单一职责原则定义：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。单一职责原则是实现高内聚、低耦合的指导方针，是最简单却最难运用的原则，需要设计人员发现类的不同职责并将其分离 2、开闭原则定义：软件实体应当对扩展开放，对修改关闭。指软件实体应尽量在不修改原有代码的情况下进行扩展。 3、里氏替换原则定义：所有引用基类的地方必须能透明地使用其子类的对象。里氏替换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。在运用里氏替换原则时，应该将父类设计为抽象类或者接口，让子类继承父类或实现父类接口，并实现在父类中声明的方法。 4、依赖倒转原则定义：高层模块不应该依赖底层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。依赖倒转原则要求：要针对接口编程，不要针对实现编程。 5、接口隔离原则定义：客户端不应该依赖那些它不需要的接口。在使用接口隔离原则的时候，需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来不方便。 6、合成复用原则定义：优先使用对象组合，而不是继承来达到复用的目的。一般而言，如果两个类之间是”Has-A”关系应使用组合或聚合，如果是”Is-A”关系可使用继承。 7、迪米特法则-又称最少知识原则定义：每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。","categories":[],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"设计原则","slug":"设计原则","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"DNS查询过程，递归查询与迭代查询","slug":"20200421-network","date":"2021-04-21T08:14:52.000Z","updated":"2021-04-22T14:25:23.694Z","comments":true,"path":"2021/04/21/20200421-network/","link":"","permalink":"http://example.com/2021/04/21/20200421-network/","excerpt":"今天复习了一下DNS的相关知识，水一篇文章记录一下。","text":"今天复习了一下DNS的相关知识，水一篇文章记录一下。 参考文章github-DNS写给前端工程师的DNS基础知识DNS解析DNS递归查询与迭代查询 DNS为了识别一个实体，TCP/IP协议通过IP地址来唯一确定一台主机到因特网的连接。但是，由于IP地址非常难记，人们更愿意用名字而不是数字来识别。因此互联网需要一种能够将名字映射为数字的目录系统。 域名系统(Domain Name System,DNS)便是这样的一个系统，为客户端提供IP地址查询的服务。我们访问网站输入网站域名，通过DNS客户端像DNS服务器发送查询请求，DNS服务器就解析我们的域名为相应的IP地址。 DNS使用UDP协议，使用客户端-服务器模型。 层次域名空间因特网使用层次结构的域名命名方法，如下图：!()[https://images2017.cnblogs.com/blog/858807/201708/858807-20170820123427006-190298208.png]一个域名可以划分为多个层次，如顶级域、二级域、三级域等，不同域名中用点隔开。 顶级域名分为： (1)国家顶级域名nTLD：采用ISO3166的规定。如：cn代表中国，us代表美国，uk代表英国，等等。国家域名又常记为ccTLD(cc表示国家代码contry-code)。 (2)通用顶级域名gTLD：最常见的通用顶级域名有7个，即：com(公司企业)，net(网络服务机构)，org(非营利组织)，int(国际组织)，gov(美国的政府部门)，mil(美国的军事部门)。 (3)基础结构域名(infrastructure domain)：这种顶级域名只有一个，即arpa，用于反向域名解析，因此称为反向域名。（已废止） !()[https://images2017.cnblogs.com/blog/858807/201708/858807-20170820123443521-1502085421.png] 域名服务器!()[https://images2017.cnblogs.com/blog/858807/201708/858807-20170820123624303-680937649.png] 根域名服务器根域名服务器全球共有13台，每一台都覆盖了整个域名空间，它并不负责查找域名，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。每个服务器都是冗余服务器的集群，以提供安全性和可靠性。 顶级域名服务器顶级域名服务器负责管理在该顶级域名服务器注册的所有二级域名（.com）。收到DNS请求时，可能直接返回查询结果，也可能返回下一步查找的服务器地址。 授权域名服务器每台主机都必须在授权域名服务器处登记，然后服务器为其授权提供IP地址。（这里不太确定，是否意思就是提供购买域名的服务的服务器） 本地域名服务器因特网服务提供者（ISP），或一所大学都可以拥有一个本地域名服务器，在发送DNS请求时，请求首先会被发送到本地域名服务器。 域名解析过程总体过程1.查询 www.baidu.com 2.访问客户端 DNS 缓存：浏览器缓存 -&gt; 系统缓存（host） -&gt; 路由器缓存 3.访问 ISP DNS 服务器（ISP，互联网服务提供商，有联通电信移动等。如果你是电信网络，则进入电信的 DNS 缓存服务器，以下简称本地），如果本地服务器有，则4.直接返回；如果没有，让本地 DNS 服务器去逐个咨询查找。 5.本地去咨询 DNS 根服务器，DNS 根服务器发现是 .com 区域 管理的，告诉本地去咨询它。 6.本地去咨询 .com 顶级域服务器，.com 域服务器告诉本地去咨询 baidu.com 主区域 的服务器。 7.本地去咨询 baidu.com 主域名服务器，baidu.com 域服务器查找到对应的 IP 地址，返回给本地。 8.本地 DNS 云服务器通知用户对方 IP 地址，同时缓存这个 IP 地址，下次就直接访问了。 递归查询与迭代查询递归查询:主机向本地域名服务器的查询一般都是采用递归查询。迭代查询:本地域名服务器向根域名服务器的查询的迭代查询。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"DNS","slug":"DNS","permalink":"http://example.com/tags/DNS/"}]},{"title":"HTTP与HTTPS，一些关键地方的理解","slug":"20210407","date":"2021-04-07T14:14:29.000Z","updated":"2021-04-08T12:35:04.497Z","comments":true,"path":"2021/04/07/20210407/","link":"","permalink":"http://example.com/2021/04/07/20210407/","excerpt":"最近在面试中被问到了HTTP与HTTPS的一些问题，今天稍微学习了一下HTTP与HTTPS，在这里整理一下一些重要地方的理解。","text":"最近在面试中被问到了HTTP与HTTPS的一些问题，今天稍微学习了一下HTTP与HTTPS，在这里整理一下一些重要地方的理解。 参考文章HTTP基础：面试带你飞：这是一份全面的 计算机网络基础 总结攻略计算机网络：这是一份全面&amp; 详细 HTTP知识讲解HTTP与HTTPS:看图学HTTPS你知道，HTTPS用的是对称加密还是非对称加密？一分钟理解 HTTPS 到底解决了什么问题主要对于证书与数字签名一些理解来自于这篇博客：即时通讯安全篇（七）：如果这样来理解HTTPS，一篇就够了 HTTP与HTTPS的区别 对称加密与非对称加密加密和解密用同一个秘钥的加密方式叫做对称加密。对于对称加密来说，服务器与客户端使用相同的加密方式，但是对于多个客户的系统来说，如果都采用同样的加密方式，那么一旦攻击者对于加密方式进行了破解，那么所有用户都将处于风险下。如果对不同用户使用不同方式进行加密，那么如果攻击者也对于加密方法进行拦截并破解，那么依然可能使用户暴露于安全风险下。 这时我们可以采用非对称加密的方法。 非对称加密会有一对秘钥：公钥和私钥。 公钥加密的内容，只有私钥可以解开，私钥加密的内容，所有的公钥都可以解开（当然是指和秘钥是一对的公钥）。 私钥只在服务器端且不公开，而公钥面向用户公开。这样，至少可以保证用户通过公钥加密的内容无法被攻击者破解（必须要拥有私钥才能解密）。 当然，这样依然会存在问题，公钥可能被中间人拿到篡改，偷偷换成他自己的公钥，这样客户使用假的公钥加密的内容将被中间人的私钥破解，然后肆意篡改。 公钥被掉包，是因为客户端无法分辨传回公钥的到底是中间人，还是服务器，这也是密码学中的身份验证问题。这样，我们就可以引入证书+数字签名的方法来解决这样的问题。 证书与数字签名服务器可以通过第三方认证机构，可以让第三方机构对自己的公钥进行加密，然后将加密后的公钥发放给客户。那么，客户如何确定自己收到的第三方加密证书是真正的服务器发来的证书，而不是中间人自己通过向第三方机构申请获得的伪造证书呢？原来，在数字证书上还附有数字签名这一东西，用参考博客里的一句原话举例： 我们从现实中找灵感。比如你是HR，你手上拿到候选人的学历证书，证书上写了持证人，颁发机构，颁发时间等等，同时证书上，还写有一个最重要的：证书编号！我们怎么鉴别这张证书是的真伪呢？只要拿着这个证书编号上相关机构去查，如果证书上的持证人与现实的这个候选人一致，同时证书编号也能对应上，那么就说明这个证书是真实的。 现实中，浏览器和操作系统都会维护一个权威的第三方机构列表（包括它们的公钥）。因为客户端接收到的证书中会写有颁发机构，客户端就根据这个颁发机构的值在本地找相应的公钥。并用公钥对证书上的内容进行解密，比对数字签名。由于数字签名这一东西是由服务端向第三方机构申请，并通过第三方机构私钥产生的，因此中间人不能伪造数字签名，以假装自己是真正的服务端，如果中间人使用了自己申请的伪造证书，那么在客户端对于证书内容解密后，会出现验证签名不匹配的情况，这样客户端就会提醒用户可能存在的安全风险了。 SSL与TLS以下内容参考自：分分钟让你理解HTTPS 作者：Keely40285 链接：https://juejin.cn/post/6844903599303032845 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 HTTPS是在通信接口部分用 TLS(Transport Layer Security 传输层安全性协议)，TLS协议采用主从式架构模型，用于在两个应用程序间通过网络创建起安全的连接，防止在交换数据时受到窃听及篡改。 SSL和TLS的关系传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。 网景公司（Netscape）在1994年推出首版网页浏览器，网景导航者时，推出HTTPS协议，以SSL进行加密，这是SSL的起源。 IETF将SSL进行标准化，1999年公布第一版TLS标准文件。随后又公布RFC 5246 （2008年8月）与 RFC 6176 （2011年3月）。在浏览器、电子邮件、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。 TLS/SSL 协议HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 SSL/TLS协议运行机制 可以看阮老师的SSL/TLS协议运行机制的概述 后话由于使用了数字证书，加密解密这样的方法，导致HTTPS相比于普通的HTTP要慢得多，但是只有支持了 HTTPS，才能部署 HTTP/2，而 HTTP/2 协议会提升速度，能够有效减轻客户端和服务器端的压力，让响应更快速。这一点就要联系到HTTP不同版本之前的区别，以及HTTP的历史了。 该图片中显示，服务端与客户端仍然使用公钥私钥，这部分实际上双方是通过对称加密生成的钥匙进行沟通的。由于非对称加密使用公钥私钥加密的计算量很大，消耗时间，所以事实上每一次对话，客户端和服务器端都生成一个”对话密钥“，用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。 如何理解呢，大致上就是说，我们把我们实际对话的对称加密密钥，用非对称加密的公钥加密一次，保证这个密钥的安全性，然后在实际对话中就可以放心的使用对称加密的密钥了。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/tags/HTTP/"}]},{"title":"画饼","slug":"20210306","date":"2021-03-06T01:41:10.000Z","updated":"2021-04-12T14:40:14.453Z","comments":true,"path":"2021/03/06/20210306/","link":"","permalink":"http://example.com/2021/03/06/20210306/","excerpt":"最近学习生活繁忙，先画一些大饼，能不能完成以后再说。。。ヽ(。&gt;д&lt;)ｐ","text":"最近学习生活繁忙，先画一些大饼，能不能完成以后再说。。。ヽ(。&gt;д&lt;)ｐ LeetCode生成题解md脚本经历了大概两个月的摸鱼，最近终于又重新开始搞LeetCode了，其实之前一直想整一个可以自动生成题解的框架，就像我之前的一些文章一样自动生成题目链接，题目简介，示例输入输出，甚至代码这样的脚本。其实实现起来应该并不难，只需要做一个爬虫就好了，然后解析一下网页把相关的内容粘下来，不过由于懒一直都没有做。。。 网易BUFF &amp;&amp; Steam社区市场爬虫这个也是老早就想做的了，由于自己是一名csgo玩家，很早之前就想做一个爬虫软件，自动将buff和steam市场的数据爬下来自己使用，当然网上也有很多现成的代码，不知道能不能使用，不过这个也是从去年就开始计划做的东西了。。。 GitHub密钥设置把这篇文章传上去之后，我收到了GitHub发来的一篇邮件，里面说要使用新的git认证方式： GitHubHi @YazidZidane,You recently used a password to access the repository at YazidZidane/yazidzidane.github.io with git using git/2.29.2.windows.3.Basic authentication using a password to Git is deprecated and will soon no longer work. Visit https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information around suggested workarounds and removal dates.Thanks,The GitHub Team 这个我暂时还没整明白是咋回事，不知道是不是跟之前搞过的ssh key一样，总之应该尽快搞一下。 后续已解决，主要就是我之前对hexo主题配置的有问题。解决这个问题，首先需要在Github中设置SSHkey，具体可以百度。设置好后，在github上点开你的仓库，然后点击Code按钮，下面会有一个可以复制的地址，格式为&#x67;&#105;&#116;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#109;:你的昵称/仓库里的.git文件，上面会显示SSH，复制这个地址。然后在hexo主题下的_config.yml文件中找到# Deployment下的deploy一栏，将其中的repo后面的内容修改为上一步中复制的地址。再次使用hexo d，就不会再提示这样的消息了。 4.12 自动填写简历脚本最近经常投各种简历嘛，然后我个人最反感的一件事就是我明明费尽心思已经制作好了一个简明，清晰，全面的简历，却还要在各种网站上一项一项的填好姓名，性别，生日，身份证号，手机，项目经历，实习经历，个人简介。。。。。。。虽然填一次两次没什么，但是天天填简直烦死了好不好！(╬｀益´)ｺ 如果能整一个自动填写简历的脚本就好了，不过感觉这个可能不太好实现，毕竟各个网页的组成也不一样，如果只用selenium写一个简单的脚本的话恐怕不太行。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"LeetCode435 无重叠区间","slug":"20201231-leetcode","date":"2020-12-31T02:39:09.000Z","updated":"2020-12-31T05:31:54.276Z","comments":true,"path":"2020/12/31/20201231-leetcode/","link":"","permalink":"http://example.com/2020/12/31/20201231-leetcode/","excerpt":"435. 无重叠区间452. 用最少数量的箭引爆气球使用贪心算法解决区间问题。","text":"435. 无重叠区间452. 用最少数量的箭引爆气球使用贪心算法解决区间问题。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/non-overlapping-intervals/ 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 435. 无重叠区间题目描述给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [[1,2],[2,3],[3,4],[1,3]] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 题目解析这道题看上去感觉还行，我第一时间想到的就是把区间看成一个一个的槽，让每个槽里只有一个元素，但这样过于抽象，不好实现。后来又想了想，觉得应该用排序，先将所有的区间按照区间开始位置进行排序，然后使用贪心算法，删除每一对相互重叠的两个区间中较大的一个。后来想了想，应该删除区间结束位置最大的一个。 这道题对我来说难点在于判断如何使用贪心算法，这里不太好想一个证明方法，我直接复制了LeetCode上的证明： 我们不妨想一想应该选择哪一个区间作为首个区间。 假设在某一种最优的选择方法中，[lk,rk] 是首个（即最左侧的）区间，那么它的左侧没有其它区间，右侧有若干个不重叠的区间。设想一下，如果此时存在一个区间 [lj,rj]，使得 rj &lt; rk ，即区间 j 的右端点在区间 k 的左侧，那么我们将区间 k 替换为区间 j，其与剩余右侧被选择的区间仍然是不重叠的。而当我们将区间 k 替换为区间 j 后，就得到了另一种最优的选择方法。 有了证明后，程序实现的方法就很好想了，可以使用双指针的方法，一个指针指向当前节点，另一个指针指向下一个节点，然后判断两个节点所在的区间是否重叠。这里可以直接比较第一个区间的结尾与第二个区间的开始的大小，如果两个区间重叠，那么应该有后面的区间的开始位置&lt;前面区间的结束位置。然后删除结束位置最大的节点，其实在实现时也并不需要真的删除节点，只要移动next指针就可以了。 代码1234567891011121314151617181920212223242526class Solution &#123;public: int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; int mincount = 0; //首先对区间数组按照区间开始的位置进行排序 sort(intervals.begin(), intervals.end()); //双指针 int curr = 0, next = 1; while (next &lt; intervals.size()) &#123; //如果后面的区间的开始位置&lt;前面区间的结束位置， 说明两区间有重叠 if (intervals[curr][1] &gt; intervals[next][0]) &#123; mincount++; //比较两区间结束位置，删除结束位置最大的 intervals[curr][1] &gt; intervals[next][1] ? curr = next : curr = curr ; next++; continue; &#125; else &#123; //两区间不重叠，双指针向前移动 curr = next; next++; &#125; &#125; return mincount; &#125;&#125;; 另外我在代码中遇到的错误就是忘记将curr设置为next的值，而是直接curr++，这样将导致curr移动到已经删除的节点上。 452. 用最少数量的箭引爆气球题目描述这道题的题干太长了而且描述的非常弱智，懒得在这抄了，直接放链接： 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 示例 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球 示例 2： 输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 题目解析这道题跟上面一道题类似，都是要找到区间数组中的重叠区间，但这题对于重叠区间进行了限制，即要求所有的重叠区间全部包含一个值/区间，如果我们把这些区间纵向排列，可以想象成用一根箭贯穿他们或是用一根棍把它们串起来。一开始我也想使用与上一题类似的排序+双指针方法直接求解，可这回我发现答案却错误了，具体错误如下： 输入：[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] 输出：1 预期：2 可以发现，代码虽然可以通过题目示例里的几个测试用例，但是却不能通过这个用例，这是因为，除去输入数组的第一项[9,12]以外，其他的数组都可以覆盖一个区间[6,7]，而区间[9,12]显然不包含这一区间。我们在上一题中通过判断前一区间的右端点和下一区间的左端点的大小，来判断两个区间是否相互覆盖。但这题中我们就需要动态地修改右端点的大小，保证所有相互覆盖的区间都能覆盖到一个相同的区间，即“用一颗子弹贯穿这些区间”。 于是在第一份代码中，我们使用了r来表示当前区间的最右端点，并在每一次遍历到新的区间时动态修改r，保证所有的当前区间均能被一颗子弹贯穿。值得注意的是，每次遍历完一个这样的区间集合时，也就是在else中才将arrows加一，这样在最后一次遍历后arrows会少1，所以在最后返回arrows+1。 而在参考答案写出的第二份代码中，由于本题中判断区间是否可被子弹打穿，主要依据的是每一个区间的右端点值，因此可以使用一种贪心的思想，每次将子弹射入的位置设定为拥有最小右端点的区间的右端点值。于是我们可以将区间按照右端点大小进行排序，这里使用了C++中的lambda表达式方法，这个方法我还不是太熟悉，具体如何使用之后应该再了解一下。总之，将所有区间排序后，我们将最小的右端点设定为子弹射入的位置，并依旧向下遍历判断下一个区间的左端点，与当前射入位置的大小，这样就可以判断子弹是否能一次贯穿这两个区间了。 这个方法相比于最开始的代码，主要是在判断上节省了判断次数，因此消耗的时间也要明显少一些。 代码123456789101112131415161718192021222324class Solution &#123;public: int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; if (!points.size()) return 0; int arrows = 0; sort(points.begin(), points.end()); int curr = 0, next = 1; int r = points[0][1]; while (next &lt; points.size()) &#123; if (points[next][0] &lt;= r) &#123; r = r &gt;= points[next][1] ? points[next][1] : r; next++; continue; &#125; else &#123; curr = next; r = points[curr][1]; next++; arrows++; &#125; &#125; return arrows + 1; &#125;&#125;; 12345678910111213141516171819class Solution &#123;public: int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; if (!points.size()) return 0; int arrows = 1; sort(points.begin(), points.end(), [](const vector&lt;int&gt;&amp; u, const vector&lt;int&gt;&amp; v) &#123; return u[1] &lt; v[1]; &#125;); int pos = points[0][1]; for (int i = 1; i &lt; points.size(); i++) &#123; if (points[i][0] &lt;= pos) continue; else &#123; pos = points[i][1]; arrows++; &#125; &#125; return arrows; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"LeetCode1046 最后一块石头的重量","slug":"20201230-leetcode","date":"2020-12-30T01:21:07.000Z","updated":"2020-12-30T02:50:01.948Z","comments":true,"path":"2020/12/30/20201230-leetcode/","link":"","permalink":"http://example.com/2020/12/30/20201230-leetcode/","excerpt":"使用priority_queue解决最大堆问题。","text":"使用priority_queue解决最大堆问题。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/last-stone-weight 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1046. 最后一块石头的重量题目描述有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。 示例： 1234567输入：[2,7,4,1,8,1]输出：1解释： 先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]， 再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]， 接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]， 最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。 题目解析这道题读完题后感觉并不是太难，只要对这堆石头，每次找出最大的两块然后敲碎，全部丢掉或者留下一块小石头继续就行了。可是我却很难想到一个高效的方法来解决这个问题。如果要使用一个有效的数据结构，那么这个结构要能保存一个按大小排列的数组，并在每次取出最大的两个数后，将可能剩下的一个数插入数组，并保持数组的有序性。如果每次都使用一次排序的话未免太复杂了些，如果使用之前刚刚学过的单调栈，又不能在敲碎两块石头后有效的处理剩下的一块石头。队列和栈看起来也不好处理这个问题。无奈之下只好再次求助答案，结果看到了“最大堆”这个说法，恍然大悟！ 其实堆很久以前数据结构就学过，大致记得是一个以二叉树形式存储数据，使所有数据满足“父节点的数值大于子节点数值”的一个数据结构。在学排序的时候还学过堆排序，应该就是先构建一个堆，然后就很好排序了。不过说实话我早就忘记了怎么实现这个数据结构，看来之后还要好好复习一下。。。。。。不过我也不记得STL里面专门有heap这种类型的数据结构，所以虽然知道了大概的方法，但还是写不出来😂 又瞟了一眼别人答案的代码，一眼看到了一个奇怪的东西priority_queue，我寻思队列怎么跟堆也扯不上关系，为啥这个优先队列就行呢？结果一看优先队列的使用方式才发现，这个“优先”正是通过堆来实现的！ 优先队列priority_queue通过与普通queue不同的地方就在于，队列中的数据优先级可以定义，并自动根据优先级排队，按照优先级顺序出队。其余入队、出队的方式就与queue一样了。底层由一个堆实现，默认是按照大根堆来实现的，也就是说，大的元素在最顶端。于是在这道题中，就可以将所有石块加入这个优先队列，这样他们就会自动按照从大到小的顺序排序，并在每次更新，加入新的石块时仍然保持排序不变。 按照概念自己瞎写了个代码，最终正确通过了，看来以后还是在刷题的同时要好好学习和复习数据结构方面的知识。 代码12345678910111213141516171819202122class Solution &#123;public: int lastStoneWeight(vector&lt;int&gt;&amp; stones) &#123; priority_queue&lt;int&gt;heap; // int stone = stones.size(); for (int i = 0; i &lt; stones.size(); i++) &#123; heap.push(stones[i]); &#125; while (heap.size() &gt; 1) &#123; int x = heap.top(); heap.pop(); int y = heap.top(); heap.pop(); if (x == y) continue; else &#123; heap.push(x - y); &#125; &#125; if (!heap.empty()) return heap.top(); else return 0; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"最大堆","slug":"最大堆","permalink":"http://example.com/tags/%E6%9C%80%E5%A4%A7%E5%A0%86/"}]},{"title":"LeetCode739 每日温度","slug":"20201225-leetcode","date":"2020-12-25T02:12:38.000Z","updated":"2020-12-25T05:21:22.005Z","comments":true,"path":"2020/12/25/20201225-leetcode/","link":"","permalink":"http://example.com/2020/12/25/20201225-leetcode/","excerpt":"第一次学习使用神奇的单调栈方法解每日温度问题。","text":"第一次学习使用神奇的单调栈方法解每日温度问题。 739. 每日温度题目描述请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 题目解析这道题开始看到题后我毫无头绪，除了用暴力解以外也完全想不出什么好办法，之前看过了好多遍，连看答案都看不太明白，也没能真正下手开始做。今天在学习leetbook中的“栈”部分时候再次遇到了这道题，决定认真学习一下。 题目官方解析的暴力法完全看不懂，各种数组套来套去不知道在说什么，故直接跳转到第二个方法————单调栈。单调栈法的文字部分也看不太懂，可是有例子就非常容易搞明白了。看了看例子，大概的思想是维护一个单调递减的栈，由于我们要找到每一个温度后面的第一个更高的温度，所以当后面温度是递减或相等的时候就把它们压入栈中保存。 如果我们遇到了比栈顶元素更高的值，那么可以有两种情况： 该值比栈中的所有元素都要大，将所有元素依次出栈后将该值压栈。 该值比栈中部分元素大，将该部分元素依次出栈后将该值压栈。 由于我们在栈中保存了之前单调递减的所有元素，所以我们可以以这些元素为依据来求出题目中要求的第一个更高的气温。我们可以用官方答案的例子作为参考。具体实现可以参考如下代码。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; stack&lt;int&gt;s; //s保存所有的温度值 stack&lt;int&gt;index; //index保存所有的索引值，与s栈保持一致 vector&lt;int&gt;result(T.size(), -1);//全部初始化为-1 for(int i = 0; i &lt; T.size(); i++)&#123; if(s.empty())&#123; s.push(T[i]); index.push(i); &#125; if(T[i] &gt; s.top())&#123; while(!s.empty())&#123; if(T[i] &gt; s.top())&#123; s.pop(); result[index.top()] = i - index.top(); index.pop(); &#125; else&#123; s.push(T[i]); index.push(i); break; &#125; &#125; if(s.empty())&#123; s.push(T[i]); index.push(i); &#125; &#125; else&#123; s.push(T[i]); index.push(i); &#125; &#125; if(!s.empty())&#123; while(!s.empty())&#123; s.pop(); result[index.top()] = 0; index.pop(); &#125; &#125; return result; &#125;&#125;; 最开始写的代码，按照我初始的逻辑写好的，又臭又长，中间有好多重复的部分可以优化。首先定义两个栈s和index，分别保存温度值和温度值对应的数组索引值，并初始化一个大小为n的数组result保存所有的结果。 代码运行时，首先对于每一个温度值进行判断，如果栈为空或该值小于栈顶值就将其加入栈中，如果大于栈顶元素时，根据上文说过的逻辑进行操作。将栈顶元素出栈，并在result数组中计算两个温度值对应索引的差值。然后再继续进行判断该值与下一个栈顶元素值的大小。 可以看到该代码中有太多重复的部分，完全可以将压栈的部分放到一起，于是进行修改之后可以得到如下代码： 123456789101112131415class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; stack&lt;int&gt;index; vector&lt;int&gt;result(T.size(), 0);//全部初始化为0,最后不用再加上处理步骤 for(int i = 0; i &lt; T.size(); i++)&#123; while(!index.empty() &amp;&amp; T[i] &gt; T[index.top()])&#123; result[index.top()] = i - index.top(); index.pop(); &#125; index.push(i); &#125; return result; &#125;&#125;; 参考答案后优化的代码，其实跟我自己按照上面代码优化的差不太多，唯一难想到的大概就是只使用index一个栈来表示温度数组，由于index保存了所有的索引，因此可以很自然的通过T[i]来索引到每一个温度的值。 除此之外，这是LeetCode上的一篇题解，上面介绍了递增栈递减栈的用法和怎么用，我感觉看完之后收获很大。 很有用的题解参考","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"单调栈","slug":"单调栈","permalink":"http://example.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"论中国足球限薪令及球队名称中性化政策","slug":"20201224-football","date":"2020-12-24T06:29:03.000Z","updated":"2020-12-24T08:17:55.720Z","comments":true,"path":"2020/12/24/20201224-football/","link":"","permalink":"http://example.com/2020/12/24/20201224-football/","excerpt":"第一次写关于中国足球的内容，文笔不好，如果文不达意还请谅解。","text":"第一次写关于中国足球的内容，文笔不好，如果文不达意还请谅解。 最近，随着中超以及足协杯，亚冠等赛事结束，2020赛季算是正式落下了帷幕，这个赛季我们一同见证了亚泰时隔两年，终于以碾压之势以中甲冠军身份成功冲超，可喜可贺，也见证了苏宁终于圆梦中超，鲁能登顶足协杯。赛季结束后，中国足协接连召开会议，发表了许多对于球队限薪，投入限制等方面的政策，这其中最令人关注的就是球队限薪令以及中姓名政策了，而这两条新政也势必会对中超乃至国足很大影响。 球员限薪对于球队限薪令来说，将外援以及国内球员的年薪全部进行限制。不难理解，足协推出这项政策的本意是希望改变现在中国足球畸形的工资情况，部分外援的工资可以在世界范围内排的上号，而国内顶尖球员的工资也是令人咋舌。对于这样的工资，许多不关注中国足球的人经常以其作为依据来批判国足，称其“领着极高薪水，表现却相差了十万八千里”，虽然我本身并不是国足的球迷，甚至有些讨厌国足，但在之前看到这样的评论，也总是忍不住要杠一下。毕竟国足再不济，也是这个国家踢足球表现最好的二三十个人了。你在任何一个行业，做到一个国家的顶尖水平，拿到最高的薪水，难道有什么问题吗？ 不过，这次的限薪政策一出，还是说明了我之前所没有考虑到的一个问题，那就是工资结构。其实之前在玩fm的时候我也注意到了，我在游戏中曾经执教过亚泰和还没解散的辽宁宏运，两家球队都是资金并不富裕，而相比于恒大，上港这样的球队，相差最大的不只是球队资金，还有球员工资。对于亚泰来说，球队工资最高的小妖和塞鸟，大概是70万每周，而主力国内球员的薪资，可能就只有四五万了，更不用说年轻球员的工资。跟恒大相比，光是国内球员的薪资水平就相差了几倍甚至十倍以上，外援就更不用说了。同时在游戏里，外援反而是最容易签下的，因为一名还不错的国内球员，甚至比外援还要稀有，而普通球员之间的差距并不是很大，于是签下一名“能用的”国内球员，需要花费的代价有时比买一名中超级别的外援还要大。我虽然不知道现实中球队的工资水平和球队资金，但从各种方面来看，可能也跟游戏里差不多了。这样下去，只会导致好的球员越来越贵，工资越来越高，穷的球队越来越养不起球员，球员之间的工资差距越来越大。的确，中国足球不缺恒大，上港这样的土豪，随手一挥就能与球员签下一笔天价合约，但这样的薪资，真的反映了球员间的真实水平吗？ 同样，在这样的薪资水平背景下富裕的球队会吸引更多国内人才巩固实力，同样也会吸引高水平外援加盟进一步提升球队上限，而相对贫穷的球队为了保级只能顺应“潮流”，既然买不起大牌国脚，就只能通过给出离谱的工资来吸引大牌外援，以便更快更有效的提升球队实力保级。这样的正反馈无疑是不健康的，最终只会导致各家球队烧钱越来越多，军备竞赛越来越激烈，而这样的最终结果就是————球队不堪重负、欠薪丑闻爆出，甚至解散。而这恰恰就是近几年中国足球各级联赛出现次数越来越多的情况。再过去，一家球队解散似乎只限于低级别联赛。而这几年，辽宁，延边，天海，这些中超边缘的球队也开始出现这样的情况，甚至最近一些中超的球队也被爆出欠薪。如果这种烧钱的竞争继续进行下去，会不会有更多的球队出现这种“玩不起”的情况呢？ 我们无法判断球员的薪资与其真实水平之间是否相匹配，也没有什么办法来判断球员拿到高薪是不是合理，只能通过我们主观的角度来批判这种现象，而这种批判丝毫无法影响土豪球队买人补强。如今足协颁布限薪令，则是从根本上为球队烧钱的行为套上了枷锁。我个人认为，这样的政策对中国足球的长远发展还是有益处的，但至于政策中的具体薪资是否合理，就只能够通过政策实施以后的实际情况来看了。 有利必有弊，虽然从工资上进行限制，可以从根本上杜绝中国足球不健康的工资结构，但砍掉最高工资之后，重新构建的工资体系又是否健康呢？这样的政策是否会导致低级别联赛的球员工资再进一步降低，乃至影响球员积极性，导致人才流失的情况呢？这些事我们就无法预测了，也只能看看未来会是什么样了。 同样的，对于外援的限薪令则是给目前的联赛来了一记重拳。这势必会导致各队的大牌外援纷纷离开，之后各家球队只能选择性价比更高的外援。这点我认为还是无需太过担忧的，毕竟十年前的中超联赛也并没有多少世界级外援，而各家球队也能玩的非常开心，即使在今天，也有许多名气不算出众，但用实力为自己正名的外援在中超赛场活跃着。不可否认，大牌外援为中超带来了许多关注度，也让中超球队在亚冠赛场上拥有了更强的竞争力，但经过这么多年来看，似乎大牌外援并没有对国内球员带来多少提高，即便是里皮这样的名帅，带了国足之后也只落得一个晚节不保。所以，对于未来中超联赛各队的外援之争，我还是非常期待的。（不期待亚泰再买金银角大王这样的球员） 另外有一个我比较在意的事，那就是规划球员们以后的工资会怎么算，虽然说他们已经是中国人了，但真的会愿意接受这样的条款吗😏 球队名中性化球队限薪令一出，球迷众说纷纭，但球队中性化这条政策一出，足协就遭到了广大球迷的口诛笔伐。因为这意味着几乎全中国职业联赛的球队都要改个名，像亚泰这样20多年如一日的球队，也要换个中性化的名字。如果说限薪令是着眼于当下，那么中性化无疑是足协着眼于未来的一步了。将现有球队球队名“地名+企业名”的形式改变，彻底删除企业的名称改为中姓名，这样有利于球迷文化建设，使一支球队长久的以所在地为根本，持续生存下去。 作为一名亚泰球迷，我可以理解足协的良苦用心，但实在无法支持自己喜爱的球队在刚刚冲上超级联赛，就面临更换名称这样的事情。毕竟，早在几年前足协的意见中，像亚泰，申花，国安，建业这样长久由一家企业运营的球队可以不用更改名称，而到了现在又要更改了，这种出尔反尔的行为让人难以接受。因为这几家球队在二十来年的历史中，早已自成一派，形成了独特的球迷团体和球队文化，在中国足球的历史上也留下了属于自己的名字，如今却除了申花都要更改名称了。 而对于足协来说想必推出这样的政策，就代表他们已经准备好得罪许多球队以及球迷。毕竟更改中姓名这件事，要不就都不改，要改就不能有特例留下。总之是一个谁都不讨好的政策。而目前一些球迷也对以后各球队的中姓名进行了讨论，好像也没有什么特别理想的名称。有些人提出像日本J联赛的一些球队，像大阪樱花，广岛三箭，鹿岛鹿角这样的名称就很好听，同时也有一定意义，可这些队名同样是存在数十年，在球迷之间一带一带流传下来才具有这样的意义的。如果突然给你来一个“东京铁塔”这样的队名，是不是感觉也有些别扭？回到我们的中超，如果各支球队队名都改成“长春人”、“上海人”、“北京人”这样的队名，我看还不如不改。 最后放一张亚泰16年保级最后一战面对上海申花时的一张图，当时亚泰1：0赢了比赛，顺利留在了中超联赛。现在放上这张图也没有什么特别的意思，只是感觉有些感慨。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"LeetCode121 买卖股票的最佳时机","slug":"20201217-leetcode","date":"2020-12-17T02:43:22.000Z","updated":"2020-12-30T01:25:14.645Z","comments":true,"path":"2020/12/17/20201217-leetcode/","link":"","permalink":"http://example.com/2020/12/17/20201217-leetcode/","excerpt":"121. 买卖股票的最佳时机 122. 买卖股票的最佳时机 II 309. 最佳买卖股票时机含冷冻期 714. 买卖股票的最佳时机含手续费 123. 买卖股票的最佳时机 III 188. 买卖股票的最佳时机 IV 剑指 Offer 63. 股票的最大利润 (与121相同) 我在LeetCode买股票之利益最大化。","text":"121. 买卖股票的最佳时机 122. 买卖股票的最佳时机 II 309. 最佳买卖股票时机含冷冻期 714. 买卖股票的最佳时机含手续费 123. 买卖股票的最佳时机 III 188. 买卖股票的最佳时机 IV 剑指 Offer 63. 股票的最大利润 (与121相同) 我在LeetCode买股票之利益最大化。 今天的LeetCode每日一题很有意思，看到股票，就想到我现在的实习，虽然跟买卖股票是没有太大关系了，这道题类似的题目之前也做过几道，而且很有意思。做完这道题后我又稍微复习了一下相关的所有问题，就把这些问题的解法写下来吧。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 121. 买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 示例 1: 1234567输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 题目解析这道题目比较简单，因为只需要进行一次买卖，因此我们只需要在价格数组中找到按顺序的最小值，以及后面的最大值，这两个值的差值就是买卖股票获得的最大利润。我们可以使用动态规划的方法，维护两个值maxprofit和minprice，来保存最大的利润以及最小价格。在每次迭代中，minprice = min(price[i], minprice)，而maxprofit = max(maxprofit, price[i] - minprice)。通过对数组进行一次遍历，就可以得到最大的利润值。 代码123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int inf = 1e9; int minprice = inf, maxprofit = 0; for (int price: prices) &#123; maxprofit = max(maxprofit, price - minprice); minprice = min(price, minprice); &#125; return maxprofit; &#125;&#125;; 122. 买卖股票的最佳时机 II题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。 随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。 题目解析这道题与上一道非常相似，不同之处在于可以进行多次买卖，甚至可以当天买入，当天卖出。但同时，个人手中不可以持有多只股票。这样，我们可以根据手中股票的状态来进行动态规划。我们可以假设dp0代表手中没有股票时，买卖股票所得到总利润，dp1代表手中持有一只股票时，买卖股票所得的总利润，类似上一道题，继续使用动态规划的方法。 我们可以得到dp0[n] = max(dp0[n - 1], dp1[n - 1] + prices[i])。我们当前手中没有股票，那么可能我们在上一天手中也没有股票，或者上一天将手中的股票卖了出去。 同样，可以得到dp1[n] = max(dp1[n - 1], dp0[n - 1] - prices[i])。如果我们手中有股票，那么可能我们在上一天也持有该股票，或者上一天刚刚买入该股票。 这样，我们再次对于数组进行一次遍历，就能得到能得到的最大利润。由于dp1肯定比dp0小（最后一天所处的状态一定是手中没有股票的，这样才能收回买卖股票所得的全部本金及利润。），所以我们直接返回dp0。 值得一提的是，因为我们在每次迭代中，只用到了dp1[n], dp0[n], dp1[n - 1], dp0[n - 1]这四个值，所以我们可以使用四个int常亮保存这四个值，这样可以节省一定的空间。 代码12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); int dp00 = 0; int dp11 = -prices[0]; int dp0 = dp00, dp1 = dp11; for(int i = 1; i &lt; prices.size(); i++)&#123; dp0 = max(dp00, dp11 + prices[i]); dp1 = max(dp11, dp00 - prices[i]); dp00 = dp0; dp11 = dp1; &#125; return dp0; &#125;&#125;; 另一个办法其实，这道题还可以有另一种巧妙的解法。由于题目没有限制买卖的次数，我们可以用一种贪心的策略，即细分到每一天考虑，如果第二天的股票价格比第一天价格高，那就执行“第一天买，第二天卖”的策略，这样只要股票价格有上涨的趋势，那我们就一定能买到所有上涨的股票。（我还不太会具体的证明）。 换一句话说，将股票的价格画成一个折线图，我们要找的就是折线图中所有上升的区间。 于是这样再写代码就容易多了，只需要每天进行判断就可以了 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int profit = 0; for(int i = 0; i &lt; prices.size() - 1; i++)&#123; if(prices[i + 1] &gt; prices[i])&#123; profit += prices[i + 1] - prices[i]; &#125; &#125; return profit; &#125;&#125;; 309. 最佳买卖股票时机含冷冻期题目描述给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例 1: 123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 题目解析这道题同样也是买卖股票，在上一道题的基础上，增加了冷冻期这一概念。说到底，只是相当于在动态规划中再次添加一个状态，也就是处于冷冻期的状态。这样就很好理解了。我第一次看到这个题时，还想了大半天怎么在上一道题的两个状态上加上各种限制，其实都不如再加上另一个状态省事。我们加上第三个状态dp10，代表此时正处于冷却期。则：dp10[i] = dp1[i - 1] + prices[i];， 如果要进入冷却期，则上一天一定持有股票，并在这天卖掉了股票。其余的状态与上一道题类似。 我们再进行一次遍历，获得最后的利润。由于我们最后的状态可以是在冷却期，或是不持有股票也不在冷却期。所以我们要取dp0与dp10的最大值。 代码1234567891011121314151617class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); if(!n)return 0; int dp0[n], dp1[n], dp10[n]; dp0[0] = 0; dp1[0] = -prices[0]; dp10[0] = 0; for(int i = 1; i &lt; n; i++)&#123; dp0[i] = max(dp0[i - 1], dp10[i - 1]); dp1[i] = max(dp0[i - 1] - prices[i], dp1[i - 1]); dp10[i] = dp1[i - 1] + prices[i]; &#125; return max(dp0[n - 1], dp10[n - 1]); &#125;&#125;; 714. 买卖股票的最佳时机含手续费题目描述给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1: 12345678输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2输出: 8解释: 能够达到的最大利润: 在此处买入 prices[0] &#x3D; 1在此处卖出 prices[3] &#x3D; 8在此处买入 prices[4] &#x3D; 4在此处卖出 prices[5] &#x3D; 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8. 题目解析这道题也是在122的基础上，添加了手续费的概念，每次交易都需要支付一定手续费，这样我们可以直接在122的基础上，为每次交易添加上手续费。然后一次遍历就能得到答案了。 代码1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int n = prices.size(); int dp0[n], dp1[n]; dp0[0] = 0; dp1[0] = -prices[0] - fee; for(int i = 1; i &lt; prices.size(); i++)&#123; dp0[i] = max(dp0[i - 1], dp1[i - 1] + prices[i]); dp1[i] = max(dp1[i - 1], dp0[i - 1] - prices[i] - fee); &#125; return dp0[n - 1]; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"互联网开发学习路线整理","slug":"20201214-learn","date":"2020-12-14T06:55:08.000Z","updated":"2020-12-15T05:12:55.480Z","comments":true,"path":"2020/12/14/20201214-learn/","link":"","permalink":"http://example.com/2020/12/14/20201214-learn/","excerpt":"","text":"学习网址与APP手机APP-慕课网：各种方面的课程，入门学习（偏基础，了解）网站-极客学院：各种方面教程，Docker，AWS教程（较深入，重点学习）网站-Java知识分享网：Java全面教程，重点：第八阶段Dubbo&amp;Springcloud教程网站-阿里云：上面有各种类型的教程，可以学习使用 前端HTML, CSS, H5, JS等等基础。。。框架： Vue国内比较多， Facebook的React，从Vue和react衍生出的Weex和React Native（RN）。移动端开发开源的：ElementUI，ant。。。。公司使用：uniapp开源框架，可以生成八种平台（iOS，Android，微信，支付宝，抖音。。。。。）基础中的基础：node.js 后端Web ServicesKafka,数据库：。。。restful -&gt; -&gt; SpringMVC -&gt; SpringBoot -&gt; SpringCloud HSF -&gt; dubbo-&gt; RPC 数据库Hadoop -&gt; 分布式计算：MapReduce 分布式存储：hdfs -&gt; Hive -&gt; sql/nosql块？数据Spark流数据：Storm sparksql Flink nosql: redis, mongodb, lucene -&gt; elastic search 类似于搜索引擎 图数据库：通过图的方式构建关系 架构总体上来说，哪里出现问题就从哪里进行改变看各种架构历史演变的帖子Tomcat&amp;db -&gt; 分离 -&gt;db分离 -&gt; db再进行修改。。。 -&gt; ？？4层 -&gt; nginx 7层 -&gt; 。。。-&gt; Hadoop。。。。。书 阿里中台战略理解中台的概念 金融科技云公有云： 阿里，腾讯，AWS，。。。学习使用4种层次，最低端代码操作 - SDK - CLI - 图形界面 理解API的意义，restful相关 大数据物联网区块链可以自己建立私链尝试。。。solidity web3.js 以太坊应用？。。 人工智能机器学习：Python -&gt; sklearn。。。。。深度学习：TF &amp; Keras 使用率最高 容器Docker &amp; KS8","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"LeetCode102 二叉树的层序遍历","slug":"20201214-leetcode","date":"2020-12-14T02:50:08.000Z","updated":"2020-12-17T02:44:17.417Z","comments":true,"path":"2020/12/14/20201214-leetcode/","link":"","permalink":"http://example.com/2020/12/14/20201214-leetcode/","excerpt":"RT，二叉树的层序遍历","text":"RT，二叉树的层序遍历 今天上午刷LeetCode心态崩了，啥题都写不出来，索性来写博客，记录一下做过的题。 题目链接LeetCode102.二叉树的层序遍历 题目描述给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点） 示例：二叉树：[3,9,20,null,null,15,7], 返回其层次遍历结果：[[3], [9,20], [15,7]] 题目解析在这道题之前我曾经做过二叉树的前中后序遍历等问题，于是一上来想到的就是各种递归的方法，但是百思不得其解。查看答案才发现自己一开始的思路就错了，原来层序遍历与前中后序遍历使用了完全不一样的方法。 这道题中我们运用了 广度优先遍历（BFS） 的方法来解决问题，每次遍历二叉树中一层的元素，然后再接着遍历下一层。 要解决这个问题我们需要用到队列这一数据结构，由于队列具有先入先出的性质，我们每次将遍历到的一层节点压入队列，然后对这些节点进行处理，将这一层节点的子节点压入队列，然后让这一层的节点出队列，再接着处理下一层的节点。 另外一个让我思考的点是，如何在输出的数组中，确定同一层的节点个数。这一问题比较好解决，因为在将一层的节点全部压入队列并处理之前，已经将上一层的节点全部弹出，所以可以在处理每层节点之前先计算这层节点的数量，然后用这个数量值作为限制处理该层的节点就可以了。 代码使用了两种方法来写代码，一种似乎是参考答案写的，每一层直接进行处理，另一种是我第二次复习时候写的，在处理每一层时新建了一个vector存储每一层的节点，然后再处理结束后将vector加入到答案vector中。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt;result; if(!root)return result; queue&lt;TreeNode*&gt;q; q.push(root); while(!q.empty())&#123; result.push_back(vector&lt;int&gt;()); int size=q.size(); for(int i=0; i&lt;size; i++)&#123; TreeNode* node=q.front(); result.back().push_back(node-&gt;val); if(node-&gt;left)q.push(node-&gt;left); if(node-&gt;right)q.push(node-&gt;right); q.pop(); &#125; &#125; return result; &#125;&#125;; 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt;result; if(!root)return result; queue&lt;TreeNode*&gt;q; q.push(root); while(!q.empty())&#123; vector&lt;int&gt;level; int size=q.size(); for(int i=0; i&lt;size; i++)&#123; level.push_back(q.front()-&gt;val); if(q.front()-&gt;left)q.push(q.front()-&gt;left); if(q.front()-&gt;right)q.push(q.front()-&gt;right); q.pop(); &#125; result.push_back(level); &#125; return result; &#125;&#125;; 总结二叉树的层序遍历作为广度优先遍历的基础，让我理解了bfs这一算法的基本框架，后面还需要再好好学习一下这一方面，毕竟都忘得差不多了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Volantis主题设置学习日记","slug":"Volantis主题设置学习日记","date":"2020-12-11T03:00:58.000Z","updated":"2020-12-15T06:48:54.444Z","comments":true,"path":"2020/12/11/Volantis主题设置学习日记/","link":"","permalink":"http://example.com/2020/12/11/Volantis%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"这是我的Volantis主题设置学习日记，主要包括我在使用Volantis过程中遇到的疑难杂症以及一些细节问题。文中所有内容以Volantis官方文档为准。","text":"这是我的Volantis主题设置学习日记，主要包括我在使用Volantis过程中遇到的疑难杂症以及一些细节问题。文中所有内容以Volantis官方文档为准。 Volantis图标设计使用Font Awesome预设图标在hexo-themes-volantis这个文件夹下的_config.yml中，我找到了Volantis主题配置的一些代码，其中，很多图标都是由fas fa-envelope或者fas fa-envelope显示的，比如在博客作者logo下显示的作者联系方式，微博推特等链接的图标： 123456789social: - icon: fab fa-facebook url: https://www.facebook.com/jingtong.xu.779 - icon: fas fa-envelope url: mailto:xjt980408@163.com - icon: fab fa-weixin url: https://www.instagram.com/xjtcoco/ - icon: fab fa-instagram-square url: https://www.instagram.com/xjtcoco/ 最开始我完全不知道这些代码的意义，但经过一番搜索，终于在这些图标的名称这一点上找到了突破，这些图标都是由一个名为Font Awesome的图标网站设计的，而在每个index.html文件的头部，都会通过一个js函数导入这些图标。在Font Awesome官方网站中，可以查到最新的Font Awesome图标的代码。而Font Awesome中文网也可以查到图标的种类（下面会说）。 然而，当我想要修改这些图标时，又遇到了麻烦，我想要在我的logo下面加入Facebook，微信和Instagram的图标作为链接，但是我将每个icon后面的图标代码修改为相应的图标代码后，重新生成页面，图标竟然无法显示。我认为，这一问题主要是由于代码前的一个代号，比如邮件的fas fa-envelope前有一个fas，而fab fa-weixin前的代号却是fab，这两者之间的区别究竟代表什么意义呢？ 又经历了一番搜索后，我终于明白了fas与fab的区别。这是由Font Awesome的新特性引起的，原来的图标前缀fa被更改了为fas，fab与far，具体哪个图标属于哪一个种类可以由上面的官网链接查看。其中，fas代表实心图标，而fab代表品牌图标，这就可以解释为什么我使用fas fa-nstagram，而在网站上无法显示的问题了。 使用图片作为图标这是我通过实验多次未果，最后百度搜索得到的结果，Hexo默认的文件位置在 /blog/source 文件目录下，因此如果在source文件夹下新建了一个images文件夹用来存放所有博客需要的图片文件，并使用rowlet.png作为我的头像（没错，就是左边那只可爱的木木枭！），那么我需要在_config.volantis.yml中的sidebar项widget_library项中的avatar设置为/images/rowlet.png，这样就可以找到正确的文件路径了。然后就可以惊喜的发现，我的头像变成了一只可爱的木木枭！ 网站统计对于博客来说，我们可以统计一下网站的总访问量以及访问次数，Volantis很方便地集成了这些功能，只不过需要自己再手动配置一些选项才能正确使用。主页的“站点信息”widget，其中有一个选项visitcounter中的service，将这一项从leancloud改成busuanzi就可以使用不蒜子的网页统计功能了，十分方便，而如果要使用leancloud的话或许需要再申请之类的，我还是觉得不蒜子的更方便一些。 当然，方便有方便的问题。在网页底部的相关信息也需要修改，这部分的配置文件在site_footer中的analytics中。这一部分的具体原理我没有太明白，因为默认使用的是leancloud的服务，所以显示数据与实际不符。我在F12检查网页源代码后，发现这一部分直接使用html代码进行配置，而两个span的id均是leancloud的id，于是我参考webbinfo中的设置，将spanid改成了busuanzi的形式，然后根据实际效果，将span内的字段移到了span外，这回似乎可以用了，如果你看到这里，可以将网页拉到最下面看一看，那里的统计数据是否正确加载，是否与首页的统计数据是否一致。 12本站总访问量为&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt; &lt;span id=&#x27;number&#x27;&gt;&lt;i class=&quot;fas fa-circle-notch fa-spin fa-fw&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/span&gt;次访客数为&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt; &lt;span id=&#x27;number&#x27;&gt;&lt;i class=&quot;fas fa-circle-notch fa-spin fa-fw&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/span&gt;人 其他问题文章中的注释在12月11日的版本中，我将写完的文章部署到GitHub上后，发现这篇文章的评论区以及侧边栏都没有正确加载出来，我开始是以为这是因为GitHub的网络延迟而导致的，可是在刷新了几遍之后问题依旧存在，这一个周末都没有怎么搞博客，也没有继续管这个问题。12月14日早晨，终于在调试了几次之后发现了玄机。原来的文章中有一大段注释，本来是我想在之后写下来的内容，因为没有写完而被注释掉了，在我删除了这段注释之后在使用hexo g &amp;&amp; hexo s生成后，显示的页面就不再有问题了。 但是，在我再次在文章的某一段落加上注释之后，同样的问题就不再生成了，所以可能也并不是注释引起的问题。。。😂 整了一上午，终于整明白了，之后还可以再搞搞别的，比如文章作者，最后修改时间等问题。","categories":[],"tags":[{"name":"Volantis","slug":"Volantis","permalink":"http://example.com/tags/Volantis/"}],"author":{"avatar":"/images/rowlet.png","name":"ted","url":"/"}},{"title":"2020-12-10:a New Article","slug":"2020-12-10-a-new-article","date":"2020-12-10T07:53:59.000Z","updated":"2020-12-10T07:54:55.403Z","comments":true,"path":"2020/12/10/2020-12-10-a-new-article/","link":"","permalink":"http://example.com/2020/12/10/2020-12-10-a-new-article/","excerpt":"","text":"This is a new article 1$ hexo server RUNOOB.COMGOOGLE.COMBAIDU.COM","categories":[],"tags":[]},{"title":"我的第一篇Markdown博客☝","slug":"我的第一篇Markdown博客☝","date":"2020-12-10T06:12:54.000Z","updated":"2020-12-30T02:48:41.094Z","comments":true,"path":"2020/12/10/我的第一篇Markdown博客☝/","link":"","permalink":"http://example.com/2020/12/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Markdown%E5%8D%9A%E5%AE%A2%E2%98%9D/","excerpt":"这是我使用markdown语法写的第一篇博客，其中主要目的是测试markdown语法的各种功能以及写一些以后可以在这个博客中继续学习的方面。","text":"这是我使用markdown语法写的第一篇博客，其中主要目的是测试markdown语法的各种功能以及写一些以后可以在这个博客中继续学习的方面。 Markdown的语法非常简单，似乎只需要通过几种格式就可以让文本变得更加生动。我要不要把这些方式全部记录下？算了，还是留下一个连接方便查阅Markdown语法比较好。接下来是一些测试环节，如果你不知道我在写什么，那就对了。 标题哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈####### 哈哈哈哈哈哈哈 Markdown最多只支持六级标题，七级就太多了。卧槽，写这么多哈，我连这个字都不认识了。 各种奇妙类型的文字带下划线的文本 这会是 斜体 的文字这会是 斜体 的文字 这会是 粗体 的文字这会是 粗体 的文字 你也 组合 这些符号 这个文字将会被横线删除 sadasdssafassadasdasdsa富豪排队静安寺欧弟和以为广大千万i###This is a new article 代码段12//C语言代码cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;endl; 123&lt;!--markdown语法--&gt;https://github.com - 自动生成！[GitHub](https://github.com) 😄","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"ted"},{"title":"Hello World","slug":"hello-world","date":"2020-12-10T05:52:48.399Z","updated":"2020-12-10T05:52:48.400Z","comments":true,"path":"2020/12/10/hello-world/","link":"","permalink":"http://example.com/2020/12/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"设计原则","slug":"设计原则","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"DNS","slug":"DNS","permalink":"http://example.com/tags/DNS/"},{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/tags/HTTP/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"最大堆","slug":"最大堆","permalink":"http://example.com/tags/%E6%9C%80%E5%A4%A7%E5%A0%86/"},{"name":"单调栈","slug":"单调栈","permalink":"http://example.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"Volantis","slug":"Volantis","permalink":"http://example.com/tags/Volantis/"}]}