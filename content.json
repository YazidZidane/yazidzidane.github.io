{"meta":{"title":"Ted Xu","subtitle":"My personal page.","description":"A simple website made by GitHub Pages, Hexo and Volantis theme.","author":"Ted Xu","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"LeetCode102 二叉树的层序遍历","slug":"20201214-leetcode","date":"2020-12-14T02:50:08.000Z","updated":"2020-12-14T03:12:34.392Z","comments":true,"path":"2020/12/14/20201214-leetcode/","link":"","permalink":"http://example.com/2020/12/14/20201214-leetcode/","excerpt":"","text":"今天上午刷LeetCode心态崩了，啥题都写不出来，索性来写博客，记录一下做过的题。 题目链接LeetCode102.二叉树的层序遍历 题目描述给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点） 示例：二叉树：[3,9,20,null,null,15,7], 返回其层次遍历结果：[[3], [9,20], [15,7]] 题目解析在这道题之前我曾经做过二叉树的前中后序遍历等问题，于是一上来想到的就是各种递归的方法，但是百思不得其解。查看答案才发现自己一开始的思路就错了，原来层序遍历与前中后序遍历使用了完全不一样的方法。 这道题中我们运用了 广度优先遍历（BFS） 的方法来解决问题，每次遍历二叉树中一层的元素，然后再接着遍历下一层。 要解决这个问题我们需要用到队列这一数据结构，由于队列具有先入先出的性质，我们每次将遍历到的一层节点压入队列，然后对这些节点进行处理，将这一层节点的子节点压入队列，然后让这一层的节点出队列，再接着处理下一层的节点。 另外一个让我思考的点是，如何在输出的数组中，确定同一层的节点个数。这一问题比较好解决，因为在将一层的节点全部压入队列并处理之前，已经将上一层的节点全部弹出，所以可以在处理每层节点之前先计算这层节点的数量，然后用这个数量值作为限制处理该层的节点就可以了。 代码使用了两种方法来写代码，一种似乎是参考答案写的，每一层直接进行处理，另一种是我第二次复习时候写的，在处理每一层时新建了一个vector存储每一层的节点，然后再处理结束后将vector加入到答案vector中。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt;result; if(!root)return result; queue&lt;TreeNode*&gt;q; q.push(root); while(!q.empty())&#123; result.push_back(vector&lt;int&gt;()); int size=q.size(); for(int i=0; i&lt;size; i++)&#123; TreeNode* node=q.front(); result.back().push_back(node-&gt;val); if(node-&gt;left)q.push(node-&gt;left); if(node-&gt;right)q.push(node-&gt;right); q.pop(); &#125; &#125; return result; &#125;&#125;; 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt;result; if(!root)return result; queue&lt;TreeNode*&gt;q; q.push(root); while(!q.empty())&#123; vector&lt;int&gt;level; int size=q.size(); for(int i=0; i&lt;size; i++)&#123; level.push_back(q.front()-&gt;val); if(q.front()-&gt;left)q.push(q.front()-&gt;left); if(q.front()-&gt;right)q.push(q.front()-&gt;right); q.pop(); &#125; result.push_back(level); &#125; return result; &#125;&#125;; 总结二叉树的层序遍历作为广度优先遍历的基础，让我理解了bfs这一算法的基本框架，后面还需要再好好学习一下这一方面，毕竟都忘得差不多了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Volantis主题设置学习日记","slug":"Volantis主题设置学习日记","date":"2020-12-11T03:00:58.000Z","updated":"2020-12-14T00:45:58.124Z","comments":true,"path":"2020/12/11/Volantis主题设置学习日记/","link":"","permalink":"http://example.com/2020/12/11/Volantis%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"","text":"Volantis图标设计使用Font Awesome预设图标在hexo-themes-volantis这个文件夹下的_config.yml中，我找到了Volantis主题配置的一些代码，其中，很多图标都是由fas fa-envelope或者fas fa-envelope显示的，比如在博客作者logo下显示的作者联系方式，微博推特等链接的图标： 123456789social: - icon: fab fa-facebook url: https://www.facebook.com/jingtong.xu.779 - icon: fas fa-envelope url: mailto:xjt980408@163.com - icon: fab fa-weixin url: https://www.instagram.com/xjtcoco/ - icon: fab fa-instagram-square url: https://www.instagram.com/xjtcoco/ 最开始我完全不知道这些代码的意义，但经过一番搜索，终于在这些图标的名称这一点上找到了突破，这些图标都是由一个名为Font Awesome的图标网站设计的，而在每个index.html文件的头部，都会通过一个js函数导入这些图标。在Font Awesome官方网站中，可以查到最新的Font Awesome图标的代码。而Font Awesome中文网也可以查到图标的种类（下面会说）。 然而，当我想要修改这些图标时，又遇到了麻烦，我想要在我的logo下面加入Facebook，微信和Instagram的图标作为链接，但是我将每个icon后面的图标代码修改为相应的图标代码后，重新生成页面，图标竟然无法显示。我认为，这一问题主要是由于代码前的一个代号，比如邮件的fas fa-envelope前有一个fas，而fab fa-weixin前的代号却是fab，这两者之间的区别究竟代表什么意义呢？ 又经历了一番搜索后，我终于明白了fas与fab的区别。这是由Font Awesome的新特性引起的，原来的图标前缀fa被更改了为fas，fab与far，具体哪个图标属于哪一个种类可以由上面的官网链接查看。其中，fas代表实心图标，而fab代表品牌图标，这就可以解释为什么我使用fas fa-nstagram，而在网站上无法显示的问题了。 使用图片作为图标这是我通过实验多次未果，最后百度搜索得到的结果，Hexo默认的文件位置在 /blog/source 文件目录下，因此如果在source文件夹下新建了一个images文件夹用来存放所有博客需要的图片文件，并使用rowlet.png作为我的头像（没错，就是左边那只可爱的木木枭！），那么我需要在_config.volantis.yml中的sidebar项-widget_library项中的avatar设置为/images/rowlet.png，这样就可以找到正确的文件路径了。然后就可以惊喜的发现，我的头像变成了一只可爱的木木枭！ 其他问题文章中的注释在12月11日的版本中，我将写完的文章部署到GitHub上后，发现这篇文章的评论区以及侧边栏都没有正确加载出来，我开始是以为这是因为GitHub的网络延迟而导致的，可是在刷新了几遍之后问题依旧存在，这一个周末都没有怎么搞博客，也没有继续管这个问题。12月14日早晨，终于在调试了几次之后发现了玄机。原来的文章中有一大段注释，本来是我想在之后写下来的内容，因为没有写完而被注释掉了，在我删除了这段注释之后在使用hexo g &amp;&amp; hexo s生成后，显示的页面就不再有问题了。 但是，在我再次在文章的某一段落加上注释之后，同样的问题就不再生成了，所以可能也并不是注释引起的问题。。。😂 整了一上午，终于整明白了，之后还可以再搞搞别的，比如文章作者，最后修改时间等问题。","categories":[],"tags":[{"name":"Volantis","slug":"Volantis","permalink":"http://example.com/tags/Volantis/"}],"author":{"avatar":"/images/rowlet.png","name":"ted","url":"/"}},{"title":"2020-12-10:a New Article","slug":"2020-12-10-a-new-article","date":"2020-12-10T07:53:59.000Z","updated":"2020-12-10T07:54:55.403Z","comments":true,"path":"2020/12/10/2020-12-10-a-new-article/","link":"","permalink":"http://example.com/2020/12/10/2020-12-10-a-new-article/","excerpt":"","text":"This is a new article 1$ hexo server RUNOOB.COMGOOGLE.COMBAIDU.COM","categories":[],"tags":[]},{"title":"我的第一篇Markdown博客☝","slug":"我的第一篇Markdown博客☝","date":"2020-12-10T06:12:54.000Z","updated":"2020-12-11T02:51:44.975Z","comments":true,"path":"2020/12/10/我的第一篇Markdown博客☝/","link":"","permalink":"http://example.com/2020/12/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Markdown%E5%8D%9A%E5%AE%A2%E2%98%9D/","excerpt":"","text":"这是我使用markdown语法写的第一篇博客，其中主要目的是测试markdown语法的各种功能以及写一些以后可以在这个博客中继续学习的方面。 Markdown的语法非常简单，似乎只需要通过几种格式就可以让文本变得更加生动。我要不要把这些方式全部记录下？算了，还是留下一个连接方便查阅Markdown语法比较好。接下来是一些测试环节，如果你不知道我在写什么，那就对了。 标题哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈####### 哈哈哈哈哈哈哈 Markdown最多只支持六级标题，七级就太多了。卧槽，写这么多哈，我连这个字都不认识了。 各种奇妙类型的文字带下划线的文本 这会是 斜体 的文字这会是 斜体 的文字 这会是 粗体 的文字这会是 粗体 的文字 你也 组合 这些符号 这个文字将会被横线删除 sadasdssafassadasdasdsa富豪排队静安寺欧弟和以为广大千万i###This is a new article 代码段12//C语言代码cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;endl; 123&lt;!--markdown语法--&gt;https://github.com - 自动生成！[GitHub](https://github.com) 😄","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"ted"},{"title":"Hello World","slug":"hello-world","date":"2020-12-10T05:52:48.399Z","updated":"2020-12-10T05:52:48.400Z","comments":true,"path":"2020/12/10/hello-world/","link":"","permalink":"http://example.com/2020/12/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"Volantis","slug":"Volantis","permalink":"http://example.com/tags/Volantis/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}