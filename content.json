{"meta":{"title":"Ted Xu","subtitle":"My personal page.","description":"A simple website made by GitHub Pages, Hexo and Volantis theme.","author":"Ted Xu","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2020-12-15T07:17:41.274Z","updated":"2020-12-15T07:17:41.274Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-12-15T05:36:39.001Z","updated":"2020-12-15T05:36:39.001Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Hello World."},{"title":"所有分类","date":"2020-12-15T05:38:17.208Z","updated":"2020-12-15T05:38:17.208Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-12-15T05:39:20.533Z","updated":"2020-12-15T05:39:20.533Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2020-12-15T05:38:52.303Z","updated":"2020-12-15T05:38:52.303Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-12-15T05:37:07.176Z","updated":"2020-12-15T05:37:07.176Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode121 买卖股票的最佳时机","slug":"20201217-leetcode","date":"2020-12-17T02:43:22.000Z","updated":"2020-12-17T05:49:21.483Z","comments":true,"path":"2020/12/17/20201217-leetcode/","link":"","permalink":"http://example.com/2020/12/17/20201217-leetcode/","excerpt":"121. 买卖股票的最佳时机 122. 买卖股票的最佳时机 II 309. 最佳买卖股票时机含冷冻期 714. 买卖股票的最佳时机含手续费 123. 买卖股票的最佳时机 III 188. 买卖股票的最佳时机 IV 剑指 Offer 63. 股票的最大利润 (与121相同) 我在LeetCode买股票之利益最大化。","text":"121. 买卖股票的最佳时机 122. 买卖股票的最佳时机 II 309. 最佳买卖股票时机含冷冻期 714. 买卖股票的最佳时机含手续费 123. 买卖股票的最佳时机 III 188. 买卖股票的最佳时机 IV 剑指 Offer 63. 股票的最大利润 (与121相同) 我在LeetCode买股票之利益最大化。 今天的LeetCode每日一题很有意思，看到股票，就想到我现在的实习，虽然跟买卖股票是没有太大关系了，这道题类似的题目之前也做过几道，而且很有意思。做完这道题后我又稍微复习了一下相关的所有问题，就把这些问题的解法写下来吧。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 121. 买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 示例 1: 1234567输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 题目解析这道题目比较简单，因为只需要进行一次买卖，因此我们只需要在价格数组中找到按顺序的最小值，以及后面的最大值，这两个值的差值就是买卖股票获得的最大利润。我们可以使用动态规划的方法，维护两个值maxprofit和minprice，来保存最大的利润以及最小价格。在每次迭代中，minprice = min(price[i], minprice)，而maxprofit = max(maxprofit, price[i] - minprice)。通过对数组进行一次遍历，就可以得到最大的利润值。 代码123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int inf = 1e9; int minprice = inf, maxprofit = 0; for (int price: prices) &#123; maxprofit = max(maxprofit, price - minprice); minprice = min(price, minprice); &#125; return maxprofit; &#125;&#125;; 122. 买卖股票的最佳时机 II题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。 随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。 题目解析这道题与上一道非常相似，不同之处在于可以进行多次买卖，甚至可以当天买入，当天卖出。但同时，个人手中不可以持有多只股票。这样，我们可以根据手中股票的状态来进行动态规划。我们可以假设dp0代表手中没有股票时，买卖股票所得到总利润，dp1代表手中持有一只股票时，买卖股票所得的总利润，类似上一道题，继续使用动态规划的方法。 我们可以得到dp0[n] = max(dp0[n - 1], dp1[n - 1] + prices[i])。我们当前手中没有股票，那么可能我们在上一天手中也没有股票，或者上一天将手中的股票卖了出去。 同样，可以得到dp1[n] = max(dp1[n - 1], dp0[n - 1] - prices[i])。如果我们手中有股票，那么可能我们在上一天也持有该股票，或者上一天刚刚买入该股票。 这样，我们再次对于数组进行一次遍历，就能得到能得到的最大利润。由于dp1肯定比dp0小（最后一天所处的状态一定是手中没有股票的，这样才能收回买卖股票所得的全部本金及利润。），所以我们直接返回dp0。 值得一提的是，因为我们在每次迭代中，只用到了dp1[n], dp0[n], dp1[n - 1], dp0[n - 1]这四个值，所以我们可以使用四个int常亮保存这四个值，这样可以节省一定的空间。 代码12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); int dp00 = 0; int dp11 = -prices[0]; int dp0 = dp00, dp1 = dp11; for(int i = 1; i &lt; prices.size(); i++)&#123; dp0 = max(dp00, dp11 + prices[i]); dp1 = max(dp11, dp00 - prices[i]); dp00 = dp0; dp11 = dp1; &#125; return dp0; &#125;&#125;; 另一个办法其实，这道题还可以有另一种巧妙的解法。由于题目没有限制买卖的次数，我们可以用一种贪心的策略，即细分到每一天考虑，如果第二天的股票价格比第一天价格高，那就执行“第一天买，第二天卖”的策略，这样只要股票价格有上涨的趋势，那我们就一定能买到所有上涨的股票。（我还不太会具体的证明）。 换一句话说，将股票的价格画成一个折线图，我们要找的就是折线图中所有上升的区间。 于是这样再写代码就容易多了，只需要每天进行判断就可以了 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int profit = 0; for(int i = 0; i &lt; prices.size() - 1; i++)&#123; if(prices[i + 1] &gt; prices[i])&#123; profit += prices[i + 1] - prices[i]; &#125; &#125; return profit; &#125;&#125;; 309. 最佳买卖股票时机含冷冻期题目描述给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例 1: 123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 题目解析这道题同样也是买卖股票，在上一道题的基础上，增加了冷冻期这一概念。说到底，只是相当于在动态规划中再次添加一个状态，也就是处于冷冻期的状态。这样就很好理解了。我第一次看到这个题时，还想了大半天怎么在上一道题的两个状态上加上各种限制，其实都不如再加上另一个状态省事。我们加上第三个状态dp10，代表此时正处于冷却期。则：dp10[i] = dp1[i - 1] + prices[i];， 如果要进入冷却期，则上一天一定持有股票，并在这天卖掉了股票。其余的状态与上一道题类似。 我们再进行一次遍历，获得最后的利润。由于我们最后的状态可以是在冷却期，或是不持有股票也不在冷却期。所以我们要取dp0与dp10的最大值。 代码1234567891011121314151617class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); if(!n)return 0; int dp0[n], dp1[n], dp10[n]; dp0[0] = 0; dp1[0] = -prices[0]; dp10[0] = 0; for(int i = 1; i &lt; n; i++)&#123; dp0[i] = max(dp0[i - 1], dp10[i - 1]); dp1[i] = max(dp0[i - 1] - prices[i], dp1[i - 1]); dp10[i] = dp1[i - 1] + prices[i]; &#125; return max(dp0[n - 1], dp10[n - 1]); &#125;&#125;; 714. 买卖股票的最佳时机含手续费题目描述给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1: 12345678输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2输出: 8解释: 能够达到的最大利润: 在此处买入 prices[0] &#x3D; 1在此处卖出 prices[3] &#x3D; 8在此处买入 prices[4] &#x3D; 4在此处卖出 prices[5] &#x3D; 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8. 题目解析这道题也是在122的基础上，添加了手续费的概念，每次交易都需要支付一定手续费，这样我们可以直接在122的基础上，为每次交易添加上手续费。然后一次遍历就能得到答案了。 代码1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int n = prices.size(); int dp0[n], dp1[n]; dp0[0] = 0; dp1[0] = -prices[0] - fee; for(int i = 1; i &lt; prices.size(); i++)&#123; dp0[i] = max(dp0[i - 1], dp1[i - 1] + prices[i]); dp1[i] = max(dp1[i - 1], dp0[i - 1] - prices[i] - fee); &#125; return dp0[n - 1]; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"互联网开发学习路线整理","slug":"20201214-learn","date":"2020-12-14T06:55:08.000Z","updated":"2020-12-15T05:12:55.480Z","comments":true,"path":"2020/12/14/20201214-learn/","link":"","permalink":"http://example.com/2020/12/14/20201214-learn/","excerpt":"","text":"学习网址与APP手机APP-慕课网：各种方面的课程，入门学习（偏基础，了解）网站-极客学院：各种方面教程，Docker，AWS教程（较深入，重点学习）网站-Java知识分享网：Java全面教程，重点：第八阶段Dubbo&amp;Springcloud教程网站-阿里云：上面有各种类型的教程，可以学习使用 前端HTML, CSS, H5, JS等等基础。。。框架： Vue国内比较多， Facebook的React，从Vue和react衍生出的Weex和React Native（RN）。移动端开发开源的：ElementUI，ant。。。。公司使用：uniapp开源框架，可以生成八种平台（iOS，Android，微信，支付宝，抖音。。。。。）基础中的基础：node.js 后端Web ServicesKafka,数据库：。。。restful -&gt; -&gt; SpringMVC -&gt; SpringBoot -&gt; SpringCloud HSF -&gt; dubbo-&gt; RPC 数据库Hadoop -&gt; 分布式计算：MapReduce 分布式存储：hdfs -&gt; Hive -&gt; sql/nosql块？数据Spark流数据：Storm sparksql Flink nosql: redis, mongodb, lucene -&gt; elastic search 类似于搜索引擎 图数据库：通过图的方式构建关系 架构总体上来说，哪里出现问题就从哪里进行改变看各种架构历史演变的帖子Tomcat&amp;db -&gt; 分离 -&gt;db分离 -&gt; db再进行修改。。。 -&gt; ？？4层 -&gt; nginx 7层 -&gt; 。。。-&gt; Hadoop。。。。。书 阿里中台战略理解中台的概念 金融科技云公有云： 阿里，腾讯，AWS，。。。学习使用4种层次，最低端代码操作 - SDK - CLI - 图形界面 理解API的意义，restful相关 大数据物联网区块链可以自己建立私链尝试。。。solidity web3.js 以太坊应用？。。 人工智能机器学习：Python -&gt; sklearn。。。。。深度学习：TF &amp; Keras 使用率最高 容器Docker &amp; KS8","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"LeetCode102 二叉树的层序遍历","slug":"20201214-leetcode","date":"2020-12-14T02:50:08.000Z","updated":"2020-12-17T02:44:17.417Z","comments":true,"path":"2020/12/14/20201214-leetcode/","link":"","permalink":"http://example.com/2020/12/14/20201214-leetcode/","excerpt":"RT，二叉树的层序遍历","text":"RT，二叉树的层序遍历 今天上午刷LeetCode心态崩了，啥题都写不出来，索性来写博客，记录一下做过的题。 题目链接LeetCode102.二叉树的层序遍历 题目描述给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点） 示例：二叉树：[3,9,20,null,null,15,7], 返回其层次遍历结果：[[3], [9,20], [15,7]] 题目解析在这道题之前我曾经做过二叉树的前中后序遍历等问题，于是一上来想到的就是各种递归的方法，但是百思不得其解。查看答案才发现自己一开始的思路就错了，原来层序遍历与前中后序遍历使用了完全不一样的方法。 这道题中我们运用了 广度优先遍历（BFS） 的方法来解决问题，每次遍历二叉树中一层的元素，然后再接着遍历下一层。 要解决这个问题我们需要用到队列这一数据结构，由于队列具有先入先出的性质，我们每次将遍历到的一层节点压入队列，然后对这些节点进行处理，将这一层节点的子节点压入队列，然后让这一层的节点出队列，再接着处理下一层的节点。 另外一个让我思考的点是，如何在输出的数组中，确定同一层的节点个数。这一问题比较好解决，因为在将一层的节点全部压入队列并处理之前，已经将上一层的节点全部弹出，所以可以在处理每层节点之前先计算这层节点的数量，然后用这个数量值作为限制处理该层的节点就可以了。 代码使用了两种方法来写代码，一种似乎是参考答案写的，每一层直接进行处理，另一种是我第二次复习时候写的，在处理每一层时新建了一个vector存储每一层的节点，然后再处理结束后将vector加入到答案vector中。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt;result; if(!root)return result; queue&lt;TreeNode*&gt;q; q.push(root); while(!q.empty())&#123; result.push_back(vector&lt;int&gt;()); int size=q.size(); for(int i=0; i&lt;size; i++)&#123; TreeNode* node=q.front(); result.back().push_back(node-&gt;val); if(node-&gt;left)q.push(node-&gt;left); if(node-&gt;right)q.push(node-&gt;right); q.pop(); &#125; &#125; return result; &#125;&#125;; 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt;result; if(!root)return result; queue&lt;TreeNode*&gt;q; q.push(root); while(!q.empty())&#123; vector&lt;int&gt;level; int size=q.size(); for(int i=0; i&lt;size; i++)&#123; level.push_back(q.front()-&gt;val); if(q.front()-&gt;left)q.push(q.front()-&gt;left); if(q.front()-&gt;right)q.push(q.front()-&gt;right); q.pop(); &#125; result.push_back(level); &#125; return result; &#125;&#125;; 总结二叉树的层序遍历作为广度优先遍历的基础，让我理解了bfs这一算法的基本框架，后面还需要再好好学习一下这一方面，毕竟都忘得差不多了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Volantis主题设置学习日记","slug":"Volantis主题设置学习日记","date":"2020-12-11T03:00:58.000Z","updated":"2020-12-15T06:48:54.444Z","comments":true,"path":"2020/12/11/Volantis主题设置学习日记/","link":"","permalink":"http://example.com/2020/12/11/Volantis%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"这是我的Volantis主题设置学习日记，主要包括我在使用Volantis过程中遇到的疑难杂症以及一些细节问题。文中所有内容以Volantis官方文档为准。","text":"这是我的Volantis主题设置学习日记，主要包括我在使用Volantis过程中遇到的疑难杂症以及一些细节问题。文中所有内容以Volantis官方文档为准。 Volantis图标设计使用Font Awesome预设图标在hexo-themes-volantis这个文件夹下的_config.yml中，我找到了Volantis主题配置的一些代码，其中，很多图标都是由fas fa-envelope或者fas fa-envelope显示的，比如在博客作者logo下显示的作者联系方式，微博推特等链接的图标： 123456789social: - icon: fab fa-facebook url: https://www.facebook.com/jingtong.xu.779 - icon: fas fa-envelope url: mailto:xjt980408@163.com - icon: fab fa-weixin url: https://www.instagram.com/xjtcoco/ - icon: fab fa-instagram-square url: https://www.instagram.com/xjtcoco/ 最开始我完全不知道这些代码的意义，但经过一番搜索，终于在这些图标的名称这一点上找到了突破，这些图标都是由一个名为Font Awesome的图标网站设计的，而在每个index.html文件的头部，都会通过一个js函数导入这些图标。在Font Awesome官方网站中，可以查到最新的Font Awesome图标的代码。而Font Awesome中文网也可以查到图标的种类（下面会说）。 然而，当我想要修改这些图标时，又遇到了麻烦，我想要在我的logo下面加入Facebook，微信和Instagram的图标作为链接，但是我将每个icon后面的图标代码修改为相应的图标代码后，重新生成页面，图标竟然无法显示。我认为，这一问题主要是由于代码前的一个代号，比如邮件的fas fa-envelope前有一个fas，而fab fa-weixin前的代号却是fab，这两者之间的区别究竟代表什么意义呢？ 又经历了一番搜索后，我终于明白了fas与fab的区别。这是由Font Awesome的新特性引起的，原来的图标前缀fa被更改了为fas，fab与far，具体哪个图标属于哪一个种类可以由上面的官网链接查看。其中，fas代表实心图标，而fab代表品牌图标，这就可以解释为什么我使用fas fa-nstagram，而在网站上无法显示的问题了。 使用图片作为图标这是我通过实验多次未果，最后百度搜索得到的结果，Hexo默认的文件位置在 /blog/source 文件目录下，因此如果在source文件夹下新建了一个images文件夹用来存放所有博客需要的图片文件，并使用rowlet.png作为我的头像（没错，就是左边那只可爱的木木枭！），那么我需要在_config.volantis.yml中的sidebar项widget_library项中的avatar设置为/images/rowlet.png，这样就可以找到正确的文件路径了。然后就可以惊喜的发现，我的头像变成了一只可爱的木木枭！ 网站统计对于博客来说，我们可以统计一下网站的总访问量以及访问次数，Volantis很方便地集成了这些功能，只不过需要自己再手动配置一些选项才能正确使用。主页的“站点信息”widget，其中有一个选项visitcounter中的service，将这一项从leancloud改成busuanzi就可以使用不蒜子的网页统计功能了，十分方便，而如果要使用leancloud的话或许需要再申请之类的，我还是觉得不蒜子的更方便一些。 当然，方便有方便的问题。在网页底部的相关信息也需要修改，这部分的配置文件在site_footer中的analytics中。这一部分的具体原理我没有太明白，因为默认使用的是leancloud的服务，所以显示数据与实际不符。我在F12检查网页源代码后，发现这一部分直接使用html代码进行配置，而两个span的id均是leancloud的id，于是我参考webbinfo中的设置，将spanid改成了busuanzi的形式，然后根据实际效果，将span内的字段移到了span外，这回似乎可以用了，如果你看到这里，可以将网页拉到最下面看一看，那里的统计数据是否正确加载，是否与首页的统计数据是否一致。 12本站总访问量为&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt; &lt;span id=&#x27;number&#x27;&gt;&lt;i class=&quot;fas fa-circle-notch fa-spin fa-fw&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/span&gt;次访客数为&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt; &lt;span id=&#x27;number&#x27;&gt;&lt;i class=&quot;fas fa-circle-notch fa-spin fa-fw&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/span&gt;人 其他问题文章中的注释在12月11日的版本中，我将写完的文章部署到GitHub上后，发现这篇文章的评论区以及侧边栏都没有正确加载出来，我开始是以为这是因为GitHub的网络延迟而导致的，可是在刷新了几遍之后问题依旧存在，这一个周末都没有怎么搞博客，也没有继续管这个问题。12月14日早晨，终于在调试了几次之后发现了玄机。原来的文章中有一大段注释，本来是我想在之后写下来的内容，因为没有写完而被注释掉了，在我删除了这段注释之后在使用hexo g &amp;&amp; hexo s生成后，显示的页面就不再有问题了。 但是，在我再次在文章的某一段落加上注释之后，同样的问题就不再生成了，所以可能也并不是注释引起的问题。。。😂 整了一上午，终于整明白了，之后还可以再搞搞别的，比如文章作者，最后修改时间等问题。","categories":[],"tags":[{"name":"Volantis","slug":"Volantis","permalink":"http://example.com/tags/Volantis/"}],"author":{"avatar":"/images/rowlet.png","name":"ted","url":"/"}},{"title":"2020-12-10:a New Article","slug":"2020-12-10-a-new-article","date":"2020-12-10T07:53:59.000Z","updated":"2020-12-10T07:54:55.403Z","comments":true,"path":"2020/12/10/2020-12-10-a-new-article/","link":"","permalink":"http://example.com/2020/12/10/2020-12-10-a-new-article/","excerpt":"","text":"This is a new article 1$ hexo server RUNOOB.COMGOOGLE.COMBAIDU.COM","categories":[],"tags":[]},{"title":"我的第一篇Markdown博客☝","slug":"我的第一篇Markdown博客☝","date":"2020-12-10T06:12:54.000Z","updated":"2020-12-11T02:51:44.975Z","comments":true,"path":"2020/12/10/我的第一篇Markdown博客☝/","link":"","permalink":"http://example.com/2020/12/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Markdown%E5%8D%9A%E5%AE%A2%E2%98%9D/","excerpt":"","text":"这是我使用markdown语法写的第一篇博客，其中主要目的是测试markdown语法的各种功能以及写一些以后可以在这个博客中继续学习的方面。 Markdown的语法非常简单，似乎只需要通过几种格式就可以让文本变得更加生动。我要不要把这些方式全部记录下？算了，还是留下一个连接方便查阅Markdown语法比较好。接下来是一些测试环节，如果你不知道我在写什么，那就对了。 标题哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈####### 哈哈哈哈哈哈哈 Markdown最多只支持六级标题，七级就太多了。卧槽，写这么多哈，我连这个字都不认识了。 各种奇妙类型的文字带下划线的文本 这会是 斜体 的文字这会是 斜体 的文字 这会是 粗体 的文字这会是 粗体 的文字 你也 组合 这些符号 这个文字将会被横线删除 sadasdssafassadasdasdsa富豪排队静安寺欧弟和以为广大千万i###This is a new article 代码段12//C语言代码cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;endl; 123&lt;!--markdown语法--&gt;https://github.com - 自动生成！[GitHub](https://github.com) 😄","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"ted"},{"title":"Hello World","slug":"hello-world","date":"2020-12-10T05:52:48.399Z","updated":"2020-12-10T05:52:48.400Z","comments":true,"path":"2020/12/10/hello-world/","link":"","permalink":"http://example.com/2020/12/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"Volantis","slug":"Volantis","permalink":"http://example.com/tags/Volantis/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}